---
 title: 【Leetcode刷题】2025年备战春招.md
---
# 数据结构目录

| 数据结构                                     | 变种                                                         | 相关题目                    | 讲解文章                            |
| -------------------------------------------- | ------------------------------------------------------------ | --------------------------- | ----------------------------------- |
| 顺序线性表：向量                             |                                                              |                             |                                     |
| 单链表                                       | 1. 双向链表 2. 静态链表 3. 对称矩阵 4. 稀疏矩阵              |                             |                                     |
| 哈希表                                       | 1. 散列函数 2. 解决碰撞/填充因子                             |                             |                                     |
| 栈和队列                                     | 1. 广义栈 2. 双端队列                                        |                             |                                     |
| 队列                                         | 1. 链表实现 2. 循环数组实现 3. 双端队列                      |                             |                                     |
| 字符串                                       | 1. KMP算法 2. 有限状态自动机 3. 模式匹配有限状态自动机 4. BM 模式匹配算法 5. BM-KMP 算法 6. BF 算法 |                             |                                     |
| 树                                           | 1. 二叉树 2. 并查集 3. Huffman 树                            |                             |                                     |
| 数组实现的堆                                 | 1. 极大堆和极小堆 2. 极大极小堆 3. 双端堆 4. d 叉堆          |                             |                                     |
| 树实现的堆                                   | 1. 左堆 2. 扁堆 3. 二项式堆 4. 斐波那契堆 5. 配对堆          |                             |                                     |
| 查找                                         | 1. 哈希表 2. 跳跃表 3. 排序二叉树 4. AVL 树 5. B 树 / B+ 树 / B* 树 6. AA 树 7. 红黑树 8. 排序二叉堆 9. Splay 树 10. 双链树 11. Trie 树 12. R 树 |                             |                                     |
| -------------------------------------------- | -------------------------------------------------------------------------------------------- | --------------------------- | ----------------------------------- |



# 算法目录

| 算法       | 具体类型                                                     | 相关题目                                                     | 讲解文章 |
| ---------- | ------------------------------------------------------------ | ------------------------------------------------------------ | -------- |
| 排序算法   | 1. 冒泡排序 2. 插入排序 3. 选择排序 4. 希尔 Shell 排序 5. 快速排序 6. 归并排序 7. 堆排序 8. 线性排序算法 9. 自省排序 10. 间接排序 11. 计数排序 12. 基数排序 13. 桶排序 14. 外部排序 - k 路归并败者树 15. 外部排序 - 最佳归并树 |                                                              |          |
| 递归与分治 |                                                              | 1. 二分搜索/查找 2. 大整数的乘法 3. Strassen 矩阵乘法 4. 棋盘覆盖 5. 合并排序 6. 快速排序 7. 线性时间选择 8. 最接近点对问题 9. 循环赛日程表 |          |
| 动态规划   |                                                              | 1. 矩阵连乘问题 2. 最长公共子序列 3. 最大子段和 4. 凸多边形最优三角剖分 5. 多边形游戏 6. 图像压缩 7. 电路布线 8. 流水作业调度 9. 0-1 背包问题/背包九讲 10. 最优二叉搜索树 11. 动态规划加速原理 12. 树型 DP |          |
| 贪心       |                                                              | 1. 活动安排问题 2. 最优装载 3. 哈夫曼编码 4. 单源最短路径 5. 最小生成树 6. 多机调度问题 |          |
| 回溯法     |                                                              | 1. 装载问题 2. 批处理作业调度 3. 符号三角形问题 4. n 后问题 5. 0-1 背包问题 6. 最大团问题 7. 图的 m 着色问题 8. 旅行售货员问题 9. 圆排列问题 10. 电路板排列问题 11. 连续邮资问题 |          |
| 搜索       | 1. 枚举 2. DFS 3. BFS 4. 启发式搜索                          |                                                              |          |
| 随机化     | 1. 随机数 2. 数值随机化算法 3. Sherwood 舍伍德算法 4. Las Vegas 拉斯维加斯算法 5. Monte Carlo 蒙特卡罗算法 | 1. 计算 π 值 2. 计算定积分 3. 解非线性方程组 4. 线性时间选择算法 5. 跳跃表 6. n 后问题 7. 整数因子分解 8. 主元素问题 9. 素数测试 |          |
| 图论       | 1. 遍历 DFS / BFS 2. AOV / AOE 网络 3. Kruskal 算法(最小生成树) 4. Prim 算法(最小生成树) 5. Boruvka 算法(最小生成树) 6. Dijkstra 算法(单源最短路径) 7. Bellman-Ford 算法(单源最短路径) 8. SPFA 算法(单源最短路径) 9. Floyd 算法(多源最短路径) 10. Johnson 算法(多源最短路径) 11. Fleury 算法(欧拉回路) 12. Ford-Fulkerson 算法(最大网络流增广路) 13. Edmonds-Karp 算法(最大网络流) 14. Dinic 算法(最大网络流) 15. 一般预流推进算法 16. 最高标号预流推进 HLPP 算法 17. Primal-Dual 原始对偶算法(最小费用流)18. Kosaraju 算法(有向图强连通分量) 19. Tarjan 算法(有向图强连通分量) 20. Gabow 算法(有向图强连通分量) 21. 匈牙利算法(二分图匹配) 22. Hopcroft－Karp 算法(二分图匹配) 23. kuhn munkras 算法(二分图最佳匹配) 24. Edmonds’ Blossom-Contraction 算法(一般图匹配) | 1. 图遍历 2. 有向图和无向图的强弱连通性 3. 割点/割边 3. AOV 网络和拓扑排序 4. AOE 网络和关键路径 5. 最小代价生成树/次小生成树 6. 最短路径问题/第 K 短路问题 7. 最大网络流问题 8. 最小费用流问题 9. 图着色问题 10. 差分约束系统 11. 欧拉回路 12. 中国邮递员问题 13. 汉密尔顿回路 14. 最佳边割集/最佳点割集/最小边割集/最小点割集/最小路径覆盖/最小点集覆盖 15. 边覆盖集 16. 二分图完美匹配和最大匹配问题 17. 仙人掌图 18. 弦图 19. 稳定婚姻问题 20. 最大团问题 |          |
| 数论       |                                                              | 1. 最大公约数 2. 最小公倍数 3. 分解质因数 4. 素数判定 5. 进制转换 6. 高精度计算 7. 整除问题 8. 同余问题 9. 欧拉函数 10. 扩展欧几里得 11. 置换群 12. 母函数 13. 离散变换 14. 康托展开 15. 矩阵 16. 向量 17. 线性方程组 18. 线性规划 |          |
| 几何       |                                                              | 1. 凸包 - Gift wrapping 2. 凸包 - Graham scan 3. 线段问题 4. 多边形和多面体相关问题 |          |
| NP 完全    | 1. 计算模型 2. P 类与 NP 类问题 3. NP 完全问题 4. NP 完全问题的近似算法 | 1. 随机存取机 RAM 2. 随机存取存储程序机 RASP 3. 图灵机 4. 非确定性图灵机 5. P 类与 NP 类语言 6. 多项式时间验证 7. 多项式时间变换 8. Cook定理 9. 合取范式的可满足性问题 CNF-SAT 10. 3 元合取范式的可满足性问题 3-SAT 11. 团问题 CLIQUE 12. 顶点覆盖问题 VERTEX-COVER 13. 子集和问题 SUBSET-SUM 14. 哈密顿回路问题 HAM-CYCLE 15. 旅行售货员问题 TSP 16. 顶点覆盖问题的近似算法 17. 旅行售货员问题近似算法 18. 具有三角不等式性质的旅行售货员问题 19. 一般的旅行售货员问题 20. 集合覆盖问题的近似算法 21. 子集和问题的近似算法 22. 子集和问题的指数时间算法 23. 子集和问题的多项式时间近似格式 |          |
| ----       | -------------------------------------------------------------------------------- | -------------------------------------------------------------- | ---      |





要找到数组中的多数元素（出现次数大于 `⌊n/2⌋` 的元素），可以使用 **Boyer-Moore 投票算法**。该算法的时间复杂度为 `O(n)`，空间复杂度为 `O(1)`，非常高效。

------

### **Boyer-Moore 投票算法**

算法的核心思想是：

1. 维护一个候选元素 `candidate` 和一个计数器 `count`。
2. 遍历数组：
   - 如果 `count` 为 0，则将当前元素设为候选元素 `candidate`。
   - 如果当前元素等于 `candidate`，则 `count++`。
   - 否则，`count--`。
3. 最终剩下的 `candidate` 就是多数元素。

**Boyer-Moore 投票算法** 中的“抵消”是一个关键概念，理解它可以帮助你更好地掌握这个算法的核心思想。下面我会用一个简单的例子来解释“抵消”是如何工作的。

---

### **抵消的核心思想**
1. **候选元素**：
   - 我们维护一个候选元素 `candidate`，假设它是多数元素。
   - 同时维护一个计数器 `count`，表示当前候选元素的“支持度”。

2. **抵消规则**：
   - 如果当前元素等于 `candidate`，说明它支持候选元素，`count++`。
   - 如果当前元素不等于 `candidate`，说明它反对候选元素，`count--`。
   - 如果 `count` 减到 0，说明当前的候选元素可能不是多数元素，需要重新选择候选元素。

3. **最终结果**：
   - 由于多数元素的数量超过 `⌊n/2⌋`，即使其他元素与多数元素“抵消”，最终剩下的仍然是多数元素。

---

### **举例说明**
假设数组为 `[2, 2, 1, 1, 1, 2, 2]`，其中 `2` 是多数元素（出现 4 次，超过 `⌊7/2⌋ = 3`）。

#### 初始化：
- `candidate = 2`（数组的第一个元素）。
- `count = 1`。

#### 遍历过程：
1. **第 1 个元素：2**
   - 当前元素 `2` 等于 `candidate`，`count++`。
   - 状态：`candidate = 2`，`count = 2`。

2. **第 2 个元素：2**
   - 当前元素 `2` 等于 `candidate`，`count++`。
   - 状态：`candidate = 2`，`count = 3`。

3. **第 3 个元素：1**
   - 当前元素 `1` 不等于 `candidate`，`count--`。
   - 状态：`candidate = 2`，`count = 2`。

4. **第 4 个元素：1**
   - 当前元素 `1` 不等于 `candidate`，`count--`。
   - 状态：`candidate = 2`，`count = 1`。

5. **第 5 个元素：1**
   - 当前元素 `1` 不等于 `candidate`，`count--`。
   - 状态：`candidate = 2`，`count = 0`。

6. **第 6 个元素：2**
   - `count` 为 0，更新 `candidate` 为当前元素 `2`，`count = 1`。
   - 状态：`candidate = 2`，`count = 1`。

7. **第 7 个元素：2**
   - 当前元素 `2` 等于 `candidate`，`count++`。
   - 状态：`candidate = 2`，`count = 2`。

#### 最终结果：
- `candidate = 2`，即多数元素。

---

### **抵消的直观理解**
- **支持与反对**：
  - 每次遇到与 `candidate` 相同的元素，相当于给 `candidate` 投一票（`count++`）。
  - 每次遇到与 `candidate` 不同的元素，相当于反对 `candidate` 一票（`count--`）。

- **多数元素的优势**：
  - 由于多数元素的数量超过 `⌊n/2⌋`，即使其他元素联合起来反对，多数元素的“票数”仍然会多于反对票。
  - 例如，在上面的例子中：
    - `2` 出现了 4 次，支持票为 4。
    - 其他元素出现了 3 次，反对票为 3。
    - 最终 `2` 的票数为 `4 - 3 = 1`，仍然是正数。

---

### **为什么最终剩下的 `candidate` 是多数元素？**
1. **假设**：
   - 如果 `candidate` 不是多数元素，那么它的票数会被其他元素“抵消”掉，最终 `count` 会减到 0。
   - 如果 `candidate` 是多数元素，即使被部分反对，最终 `count` 仍然会大于 0。

2. **数学保证**：
   - 多数元素的数量超过 `⌊n/2⌋`，因此它的票数一定多于其他元素的总票数。
   - 即使其他元素联合起来反对，多数元素的票数仍然会胜出。

---

### **总结**
- **抵消** 是 Boyer-Moore 投票算法的核心思想，通过支持与反对的动态平衡，最终找到多数元素。
- 这个算法的优点是高效（时间复杂度 `O(n)`，空间复杂度 `O(1)`），适合处理大规模数据。
- 如果你理解了“抵消”的概念，就能轻松掌握这个算法的精髓！





1. **初始化**：
   - 用一个变量 `minPrice` 记录当前的最低价格。
   - 用一个变量 `maxProfit` 记录当前的最大利润。
2. **遍历数组**：
   - 对于每一天的价格：
     - 如果当前价格比 `minPrice` 更低，更新 `minPrice`。
     - 否则，计算当前价格与 `minPrice` 的差值，如果这个差值大于 `maxProfit`，更新 `maxProfit`。
3. **返回结果**：
   - 最终 `maxProfit` 就是最大利润。





# 贪心问题跳跃游戏



通过贪心算法来解决。我们可以维护一个变量 `max_reach`，表示当前能够到达的最远位置。遍历数组时，更新 `max_reach`，并检查是否能够到达或超过最后一个下标。

### 具体步骤：

1. 初始化 `max_reach` 为 0，表示当前能够到达的最远位置。
2. 遍历数组 `nums`，对于每个位置 `i`：
   - 如果 `i > max_reach`，说明无法到达当前位置，直接返回 `false`。
   - 更新 `max_reach` 为 `max(max_reach, i + nums[i])`，表示从当前位置能够跳跃到的最远位置。
   - 如果 `max_reach` 已经大于或等于最后一个下标，返回 `true`。
3. 如果遍历结束后还没有返回 `true`，则返回 `false`。







# 贪心问题跳跃游戏

### **关键思想**

- **`current_end`**：表示当前跳跃能到达的最远位置。
- **`max_far`**：表示从当前位置到`current_end`之间，所有位置能跳到的最远位置。
- **`jumps`**：记录跳跃的次数。

当我们遍历数组时，每次到达`current_end`时，意味着我们已经用尽了当前跳跃的范围，必须进行一次新的跳跃，才能继续前进。

### **为什么遍历到`current_end`表示需要进行一次跳跃？**

1. **跳跃的范围**：
   - 假设我们从位置`i`开始跳跃，跳跃的范围是`[i, i + nums[i]]`。
   - 在这个范围内，我们可以选择跳到任意一个位置。
2. **贪心策略**：
   - 为了最小化跳跃次数，我们希望每次跳跃都尽可能跳得更远。
   - 因此，在当前位置到`current_end`之间，我们会不断更新`max_far`，记录从这些位置能跳到的最远位置。
3. **到达`current_end`时的意义**：
   - 当我们遍历到`current_end`时，意味着我们已经用尽了当前跳跃的范围。
   - 此时，我们必须进行一次新的跳跃，才能继续前进。
   - 新的跳跃范围是从`current_end`到`max_far`。

### 换个理解

1. **`current_end`是当前跳跃的边界**：
   - 在遍历数组时，`current_end`表示当前跳跃能到达的最远位置。
   - 在`current_end`之前的所有位置，都可以通过当前跳跃到达。
2. **`max_far`是下一步跳跃的最远范围**：
   - 在遍历到`current_end`之前，我们会不断更新`max_far`，记录从当前位置到`current_end`之间所有位置能跳到的最远位置。
   - 这个`max_far`就是下一步跳跃的边界。
3. **到达`current_end`时表示需要一次新的跳跃**：
   - 当遍历到`current_end`时，表示我们已经用尽了当前跳跃的范围。
   - 此时，必须进行一次新的跳跃（`jumps++`），才能继续前进。
   - 新的跳跃范围是从`current_end`到`max_far`。
4. **更新`current_end`为`max_far`**：
   - 每次跳跃后，`current_end`更新为`max_far`，表示新的跳跃边界。
   - 这样，我们就可以继续遍历数组，直到到达最后一个位置。





# 除自身以外元素的乘积



1. **初始化结果数组**：
   - 使用 `make` 创建一个长度为 `n` 的切片 `answer`，用于存储结果。
2. **计算前缀积**：
   - 从左到右遍历数组，计算每个位置左边所有元素的乘积，并存储在 `answer` 中。
   - `prefix` 变量用于累乘左边的元素。
3. **计算后缀积并更新结果**：
   - 从右到左遍历数组，计算每个位置右边所有元素的乘积，并将其与 `answer` 中的值相乘。
   - `suffix` 变量用于累乘右边的元素。
4. **返回结果**：
   - 最终返回 `answer` 切片。

- **前缀积**：对于数组中的每个元素 `nums[i]`，前缀积是它左边所有元素的乘积。
  例如，数组 `[a, b, c, d]` 中，`c` 的前缀积是 `a * b`。
- **后缀积**：对于 `nums[i]`，后缀积是它右边所有元素的乘积。
  例如，`b` 的后缀积是 `c * d`。

最终结果 `answer[i] = 前缀积[i] * 后缀积[i]`。这种方法避免了除法，同时满足时间复杂度 `O(n)` 和空间复杂度 `O(1)`（输出数组不计入空间）。



# 贪心问题加油站

1. **总油量检查**：
   - 计算 `gas[i] - cost[i]` 的总和 `totalTank`。
   - 如果 `totalTank < 0`，说明总油量不足以绕环路行驶一周，直接返回 `-1`。
2. **贪心选择起点**：
   - 遍历每个加油站，计算净油量 `margin = gas[i] - cost[i]`。
   - 维护当前油箱的剩余油量 `currentTank`。
   - 如果 `currentTank < 0`，说明从当前起点无法继续前进，将起点设为下一个加油站，并重置 `currentTank`。
3. **返回结果**：
   - 如果遍历结束后 `totalTank >= 0`，说明存在解，返回起点 `start`。
   - 否则返回 `-1`。





# 数论

## [LCR 072. x 的平方根](https://leetcode.cn/problems/jJ0w9p/)：牛顿迭代法

泰勒展开第二项进行运算

![image-20250206133342150](C:\Users\Jinju\blog\source\images\image-20250206133342150.png)

```
   toleration := 0.001
	x0 := float64(1.0)
	for {
	
		x1 :=float64(x0 - (x0*x0-float64(x))/(2*x0)) 
		
		if diff := x1 - x0; diff < toleration && -diff < toleration {
			break
			}
			x0 = x1
		}
        result:=int(x0)
		if result*result > x {
		    return result - 1
	    }
		return result
```

参考链接：https://www.bilibili.com/video/BV1px4y127PD/?spm_id_from=333.1391.0.0&vd_source=9a75a4b5f792c3cd3b921c00fec104bb
