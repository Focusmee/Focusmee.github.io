<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>动态规划 - 技术博客</title>
    <meta name="description" content="动态规划 - 算法相关技术文章">
    <meta name="keywords" content="算法, 技术博客, 编程, 开发">
    
    <!-- CSS样式文件 -->
    <link rel="stylesheet" href="../../styles/main.css">
    <link rel="stylesheet" href="../../styles/post.css">
    <link rel="stylesheet" href="../../styles/highlight.css">
</head>
<body>
    <!-- 顶部导航栏 -->
    <nav class="navbar">
        <div class="nav-container">
            <a href="../../index.html" class="nav-brand">📚 技术博客</a>
            <div class="nav-links">
                <a href="../../index.html" class="nav-link">首页</a>
                <a href="../../blog.html" class="nav-link">博客</a>
            </div>
        </div>
    </nav>

    <!-- 面包屑导航 -->
    <div class="breadcrumb">
        <div class="container">
            <a href="../../index.html">首页</a>
            <span class="separator">›</span>
            <a href="../../blog.html">博客</a>
            <span class="separator">›</span>
            <span class="category-breadcrumb">算法</span>
            <span class="separator">›</span>
            <span class="current-page">动态规划</span>
        </div>
    </div>

    <!-- 文章容器 - 目录功能会在这里动态插入 -->
    <div class="container">
        <article class="post-container">
            <!-- 文章头部 -->
            <header class="post-header">
                <div class="post-meta">
                    <span class="category-tag algorithm">🧮 算法</span>
                    <time class="publish-date" datetime="2025-06-25">2025-06-25</time>
                    <span class="read-time">📖 14 分钟阅读</span>
                </div>
                <h1 class="post-title">动态规划</h1>
            </header>
            
            <!-- 文章内容 -->
            <main class="post-content">
                <p>[TOC]<br /><br /><h1>title: 动态规划</h1><br /><br /><h3>动态规划方法论以及背包问题</h3><br /><br /><strong>状态表示</strong>f[i,j]<br /><br />​		集合 <br /><br />​				所有选法<br /><br />​				条件 1. 只从前i个物品中选 2. 总体积<=j<br /><br />​				背包问题：所有只从前i个物品选，并且总体积不超过j的选法<br /><br />​									只从前i组物品中选，并且总体积不超过j的选法<br /><br />​		属性 MAX MIN 个数<br /><br /><strong>状态计算</strong> 集合的划分<br /><br />​				01背包 `f[i][j]=Max(f[i-1][j],f[i-1][j-v[i]]+w[i])`<br /><br />​							      优化后：`f[j]=Max(f[j],f[j-v[i]]+w[i])`<br /><br />​				完全背包  优化前：`f[i][j]=Max(f[i-1][j],f[i][j-v[i]<em>k]+w[i]</em>k)`<br /><br />​												注意这里Max里的`f[i][j]`，因为`k`从0开始的，所以`k=0`的时候就是不包含`i`的集合，然后找到选几个`i`这个种类的物品价值最大<br /><br />​								 优化后：`f[i][j]=Max(f[i-1][j],f[i][j-v]+w)`<br /><br />​				多重背包  优化前：`f[i][j]=max(f[i][j],f[i-1][j-v[i]<em>k]+w[i]</em>k);`<br /><br />​								 二进制优化：多重背包问题通常可转化成01背包问题求解，对物品进行优化，即：一个正整数n，可以被分解成1,2,4,…,2^(k-1)^的形式。其中，k是满足n-2^k^+1>0的最大整数。例如，假设给定价值为2，数量为10的物品，依据二进制优化思想可将10分解为1+2+4+3，则原来价值为2，数量为10的物品可等效转化为价值分别为1<em>2，2*2，4*2，3</em>2，即价值分别为2，4，8，6，数量均为1的物品。//<a href="https://blog.csdn.net/hnjzsyjyj/article/details/109363826">(43条消息) 多重背包问题（二进制优化）_hnjzsyjyj的博客-CSDN博客_多重背包二进制优化</a><br /><br /><img src="C:\Users\乌拉拉巴卡巴卡\AppData\Roaming\Typora\typora-user-images\image-20220920150014343.png" alt="image-20220920150014343" style="zoom: 50%;" /> <br /><br /><strong>注意遍历顺序</strong>： 如果是排序问题所以需将target放在外循环，将nums放在内循环<br /><br />​							如果是组合问题就target放里面，nums放外面<br /><br />关于为什么<strong>当问题为组合问题时：先遍历物品，再遍历背包<em>* *</em>当问题为排列问题时：先遍历背包，再遍历物品</strong><br /><br />我认为 组合是只考虑我是否选了第i个物品，选择第i个物品后状态发生的变化 当考虑过第i种物品后，考虑后面新的物品时候就不会再往前看第i个物品<br /><br />​			而排列，则是我每次考虑到不同容量的时候，都要考虑每种物品是否能填进去，就会造成为了导致填满而发生顺序上的改变<br /><br /><a href="https://leetcode.cn/problems/unique-binary-search-trees/">96. 不同的二叉搜索树</a><br /><br />这个就是组合<br /><br />令`f(0) = 1`<br />`f(1) = f(0)*f(0)`<br />`f(2) = f(1)<em>f(0) + f(0)</em>f(1)`<br />`f(3) = f(2)<em>f(0) + f(1)*f(1) + f(0)</em>f(2)`<br />……<br />`f(n) = f(n-1)<em>f(0) + f(n-2)*f(1) +……f(0)</em>f(n-1)`<br /><br /> <a href="https://leetcode.cn/problems/length-of-longest-fibonacci-subsequence/">873. 最长的斐波那契子序列的长度</a><br /><br /><br /><br /><br /><br /><a href="https://leetcode.cn/problems/get-maximum-in-generated-array/">1646. 获取生成数组中的最大值</a><br /><br /><a href="https://leetcode.cn/problems/partition-array-for-maximum-sum/">1043. 分隔数组以得到最大和</a><br /><br />```<br />int maxSumAfterPartitioning(int* arr, int arrSize, int k){<br />     int dp[501]={0};<br />     for(int i=1;i<arrSize+1;i++)<br />     {<br />         int max=arr[i-1];<br />         dp[i] = dp[i - 1] + arr[i-1];<br />         for(int j=i-1;j>i-k&&j>0;j--)<br />         {   <br />             max=fmax(arr[j-1],max);<br />             dp[i]=fmax(dp[i],dp[j-1]+(i-j+1)*max);<br />         }<br />     }<br />     return dp[arrSize];<br />}<br />```<br /><br />##### 完全背包问题<br /><br />###### <a href="https://leetcode.cn/problems/word-break/">139. 单词拆分</a><br /><br />回溯经典超时<br /><br />```<br />bool backtracking(char <em> s,int sSize,char *</em>wordDict,int wordDictSize)<br />{<br />    if(*s=='\0') return true;<br />    for(int i=0;s[i]!='\0';i++)<br />    {<br />        for(int j=0;j<wordDictSize;j++)<br />        {<br />            if(i+1==strlen(wordDict[j])){<br />                int k;<br />                for(k=0;k<=i;k++)<br />                {<br />                    if(s[k]!=wordDict[j][k]) break;<br />                }<br />               <br />                if(k==i+1)  <br />                {<br />                    if(backtracking(s+i+1,sSize,wordDict,wordDictSize)==true) return true;<br />                }<br />            }<br />            else continue;<br />        }<br />    }<br />    return false;<br />}<br />bool wordBreak(char <em> s, char *</em> wordDict, int wordDictSize){<br />int<em> memo=(int*)malloc(sizeof(int)</em>(strlen(s)+1));<br />memset(memo,-1,sizeof(int)*(strlen(s)+1));<br />    return backtracking(s,strlen(s),wordDict,wordDictSize);<br />}<br />```<br /><br />###### <a href="https://leetcode.cn/problems/coin-change/">322. 零钱兑换</a><br /><br /><strong>注意</strong>：这里是组合，所以直接target在内，sum在外，然后完全背包问题<br /><br />状态表示f[i,j]	集合：从i种零前拿出amount值的最少硬币选法<br /><br />​						  条件：只从前i个选，并且总金额要等于j的选法<br /><br />​						  属性：<strong>最少的硬币个数</strong><br /><br />状态计算	集合的划分 `f[i][j]=min(f[i][j-coins[i]*k]+k,f[i-1][j])`<br /><br />​					完全背包问题的优化后：`f[i][j]=min(f[i][j-coins[i]]+1,f[i-1][j])`<br /><br />​							    优化成一位数组：`f[j]=min[f[j-coins[j]]+1,f[j]]` 注意，因为属性为最少的硬币个数，所以要初始化要注意<br /><br />考虑到集合的性质,当还没选的时候不确定是否能可以用硬币表示，则需要硬币的数量是无穷大的，而`f[0]`注意单独赋值，因为`f[0]`为表示`account=0`的时候需要的最少的硬币个数，其实就是0。<br /><br />###### <a href="https://leetcode.cn/problems/coin-change-2/">518. 零钱兑换 II</a><br /><br /><strong>注意<em>*：这里并没有将顺序不同的序列被视作不同的组合。 所以这个是组合问题而不是排列问题，*</em>所以需将target放在外循环，将nums放在内循环</strong>。<br /><br />状态表示f[i,j]	集合：所有选法：从i种零钱拿出amount值的所有选法<br /><br />​									 条件：只从前i个物品选，并且总金额要等于j的选法<br /><br />​									 属性：个数<br /><br />状态计算	集合的划分<br /><br />###### <a href="https://leetcode.cn/problems/combination-sum-iv/">377. 组合总和 Ⅳ</a><br /><br /><strong>注意</strong>：这里将顺序不同的序列被视作不同的组合。//所以这里跟完全背包有明显的细节差异，完全背包是当你包含第i种数字的时候的情况，这样只会出现就不能将顺序不同的序列算进组合。对任意的` f[len][target]`而言，组合中的最后一个数字可以选择 nums 中的任意数值，因此` f[len][target]` 应该为以下所有方案总和<br /><br />记得初始化 `f[0]=1`<br /><br />状态表示`f[i,j] `集合：所有选法：从i种数字拿出target的所有组合选法<br /><br />​									条件：只从前i个数字选，并且总和要等于j的选法<br /><br />​									属性：个数<br /><br />状态计算 集合的划分 `f[i][j]+=f[i-1][j]+f[i][j-v[i]]` 优化后：`f[j]=f[j]+f[j-v[i]]`<br /><br />##### <a href="https://leetcode.cn/problems/climbing-stairs/">70. 爬楼梯</a><br /><br />实际上是完全背包问题，还是靠排列的，所以target在外，num在内<br /><br /><img src="C:\Users\乌拉拉巴卡巴卡\AppData\Roaming\Typora\typora-user-images\image-20220920183646504.png" alt="image-20220920183646504" style="zoom:67%;" /> <br /><br /><strong><a href="https://leetcode.cn/problems/word-break/">139. 单词拆分</a></strong><br /><br />完全背包问题，单词当作物品，字符串 `s` 长度当作背包容量，目的是判断物品是否能恰好填满背包。<br /><br />能否恰好放入背包 <br /><br />一是取决于背包是否留下足够多的空间放下。<br /><br />二是前面的空间是填满了的<br /><br /><br /><br />##### <a href="https://www.acwing.com/problem/content/description/900/">898. 数字三角形 - AcWing题库</a><br /><br /> memset(f, -0x3f, sizeof f);<br /><br />##### <br /><br /><br /><br />#### 区间DP <br /><br />##### <a href="https://www.acwing.com/problem/content/284/">282. 石子合并 - AcWing题库</a><br /><br />`f[i][j]`表示将第i堆石子到第j堆石子合并成一堆石子的最小代价<br /><br />状态表示`f[i][j]` 集合 所有将第i堆石子到第j堆石子合并成一堆石子的合并方式<br /><br />​								属性 Min<br /><br />状态表示	根据i~j划分成两堆,以分界线 k=j-i+1<br /><br />1 2 3 4 ... k-1  <br /><br />`f[i][j]=Min(f[i][j],f[i][k]+f[k+1][j]+s[j]-s[i-1])` s这里表示的是前缀和<br /><br /><br /><br />#### 打家劫舍<br /><br />##### <a href="https://leetcode.cn/problems/house-robber/">198. 打家劫舍</a><br /><br />`f[i]` 集合表示在偷第i号屋子的所有结合<br /><br />​		   属性 Max<br /><br />状态表示 集合的划分<br /><br />没选i号屋子偷窃 选i号屋子偷窃<br /><br />`f[i]=Max(f[i-1],f[i-2]+w[i])`<br /><br />##### <a href="https://leetcode.cn/problems/house-robber-ii/">213. 打家劫舍 II</a><br /><br />`f[i][j]` 集合表示在偷第i号房子的所有集合 <br /><br />​				属性 Max<br /><br />`f[i][j]`表示偷了第i号房子且是否偷了第一个的所有集合中的最大值<br /><br />状态表示 集合的划分<br /><br />1. 选了第一个偷：<br />   1.  没选i号屋子偷窃；<br />   2.  选i号屋子偷窃<br />2. 没选第一个偷<br />   1.  没选i号屋子偷窃；<br />   2.  选i号屋子偷窃<br /><br />`f[i][0]=Math.max(f[i-1][0],f[i-2][0]+nums[i-1]);`<br /><br />`f[i][1]=Math.max(f[i-1][1],f[i-2][1]+nums[i-1]);`<br /><br />最后单独考虑情况。<br /><br />###### 树形DP<br /><br />##### <a href="https://leetcode.cn/problems/house-robber-iii/">337. 打家劫舍 III</a><br /><br />二叉树要从下往上判断，需要用到后序遍历<br /><br />（如果是从上往下判断是无法知道这个节点到底是取还是不取的，不知道其孩子的情况）<br /><br />判断一个节点是否要偷<br /><br />要看其两个左右子节点和父节点之和是否大于它本身，大于则取左右子孩子，不大于就取它本身，而且还要考虑如果取它本身，<br /><br /><br /><br />#### 股票问题<br /><br />股票问题最简单的方法就是表示状态<br /><br />买卖股票的状态有：<br /><br />1. 天数<br />2. 当前是否持有股票<br />3. 交易次数<br /><br />`f[i][j][k]`表示在第i天，是否持有股票，交易次数有k次的最大利益<br /><br />状态表示`f[i][j][k]`集合 所有第i天持有或者不持有股票已经交易了k次的买卖股票方式<br /><br />​									  属性 Max<br /><br />状态<br /><br /><br /><br />##### <a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/">121. 买卖股票的最佳时机</a><br /><br />一维dp数组，dp含义是当第i天时的最大利润，遍历顺序为从前到后，前i天的最大收益 = max{前i-1天的最大收益，第i天的价格-前i-1天中的最小价格}<br /><br />##### <a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">122. 买卖股票的最佳时机 II</a><br /><br /><img alt="image-20220930093634130" src="C:\Users\乌拉拉巴卡巴卡\AppData\Roaming\Typora\typora-user-images\image-20220930093634130.png" /><br /><br /><img alt="image-20220930093658243" src="C:\Users\乌拉拉巴卡巴卡\AppData\Roaming\Typora\typora-user-images\image-20220930093658243.png" /><br /><br /><img src="C:\Users\乌拉拉巴卡巴卡\AppData\Roaming\Typora\typora-user-images\image-20220930094058646.png" alt="image-20220930094058646" style="zoom:50%;" /><br /><br />#### 子序列问题<br /><br />##### 子序列（不连续）<br /><br />###### <a href="https://leetcode.cn/problems/longest-increasing-subsequence/">300. 最长递增子序列</a><br /><br />```c<br />int max(int a,int b)<br />{<br />    return a>b?a:b;<br />}<br />int lengthOfLIS(int* nums, int numsSize){<br />int dp[2500]={0};<br />int ans=1;<br />for(int i=0;i<numsSize;i++)<br />{<br />    dp[i]=1;<br />}<br />for(int i=1;i<numsSize;i++)<br />{<br />    for(int j=0;j<i;j++)<br />    {<br />        if(nums[i]>nums[j])<br />        {<br />            dp[i]=max(dp[i],dp[j]+1);<br />            ans=max(dp[i],ans);<br />        }<br />    }<br />}<br />return ans;<br />}<br />```<br /><br />确定状态 状态表示的是以当前为结尾的最长递增子序列。<br /><br />初始化 <br /><br />遍历<br /><br />##### 子序列（连续）<br />###### <a href="https://leetcode.cn/problems/longest-common-subsequence/">1143. 最长公共子序列</a><br /><br />状态表示 `f[i,j]` 集合 <strong>所有在第一个序列的前i个字母中出现，且在第二个序列的前j个字母中出现的子序列</strong><br /><br />`f[i][j]`表示在第一个序列的前i个字母中出现并且在第二个序列的前j个字母中出现的最大值<br /><br />​								属性 Max<br /><br />状态表示 根据公共序列包含a[i]和b[j]来进行集合划分<br /><br />​              		`f[i,j]`<br /><br />00								01						10							11<br /><br />`f[i-1][j-1]`		`f[i-1][j]`		`f[i][j-1]`				`f[i-1][j-1]`+1<br /><br /><img alt="image-20230503172714169" src="C:\Users\乌拉拉巴卡巴卡\AppData\Roaming\Typora\typora-user-images\image-20230503172714169.png" /><br /><br />​								注意中间这两个的情况，例如`f[i-1][j]`并不是说明b[i]一定包含在公共子序列中，但`f[i-1][j]`所表示的一个公共子序列的集合中却表示了b[i]在公共子序列中的情况，也就是`f[i-1][j]`所表示的所有在第一个序列的前i-1个字母中出现，且在第二个序列的前j个字母中出现的子序列所包含了一种情况就是b[i]存在而a[i]严格不存在的子序列，当然`f[i-1][j]`也不一定说明a[i]一定有或者b[i]一定有，也包含两者都没有的情况，所有00的情况其实就在`f[i-1][j]`里面。<br /><br />10的情况也同理。<br /><br />11表示都包含，所有在第一个序列的前i个字母中出现，且在第二个序列的前j个字母中出现的子序列比第一个序列的前i-1个字母中出现，且在第二个序列的前j个字母中出现的子序列长度+1。<br /><br />求最大值不能漏情况，但可以重叠情况，`f[i-1][j]`和`f[i][j-1]`有重叠的情况，都重复考虑了a[i]和b[i]至多有一个存在的情况，但不影响结果。<br /><br />##### 编辑距离<br /><br />###### <a href="https://leetcode.cn/problems/is-subsequence/">392. 判断子序列</a><br /><br />###### <a href="https://leetcode.cn/problems/edit-distance/">72. 编辑距离</a><br /><br />##### 回文<br /><br />###### <a href="https://leetcode.cn/problems/palindromic-substrings/">647. 回文子串</a><br /><br />状态表示	`dp[i][j]`表示在i~j区间的子串里是否是回文子串<br /><br />```<br />int countSubstrings(char * s){<br />    if(s==NULL) return 0;<br />  <br />    int l=strlen(s);<br />      if(l==1) return 1;<br />    bool dp[l][l];<br />    memset(dp,0,sizeof(dp));<br />    int ans=0;<br />    for(int i=l-1;i>=0;i--)<br />    {<br />        for(int j=i;j<l;j++)<br />        {<br />            if(s[i]==s[j])<br />            {<br />                if(i==j) <br />                {dp[i][j]=true;<br />                continue;}<br />                if(j-i==1) <br />                {dp[i][j]=true;<br />                continue;}<br />                if(j-i>1) dp[i][j]=dp[i+1][j-1];<br />            }<br />            <br />        }<br />        <br />    }<br />    for(int i=0;i<l;i++)<br />    {<br />        for(int j=0;j<l;j++)<br />        {<br />            printf("%d ",dp[i][j]);<br />            if(dp[i][j]==true) ans++;<br />        }<br />        printf("\n");<br />    }<br /><br />    return ans;<br />}<br />```<br /><br /><br /><br />###### <a href="https://leetcode.cn/problems/longest-palindromic-subsequence/">516. 最长回文子序列</a><br /><br />```<br />int longestPalindromeSubseq(char * s){<br />    int l=strlen(s);<br />    int dp[l+1][l+1];<br />    memset(dp,0,sizeof(dp));<br />    for(int i=l;i>=0;i--)<br />    {<br />        for(int j=i;j<=l;j++)<br />        {<br />            if(i==0)<br />            {<br />                dp[i][j]=1;continue;<br />            }<br />            if(j==i) {<br />                dp[i][j]=1;continue;<br />            }<br />            if(s[i-1]==s[j-1]) dp[i][j]=dp[i+1][j-1]+2;<br />            else dp[i][j]=fmax(dp[i+1][j],dp[i][j-1]);<br />        }<br />    }<br />    return dp[1][l];<br />}<br />```<br /><br /><br /><br /><br /><br />###### <a href="https://leetcode.cn/problems/maximum-students-taking-exam/">1349. 参加考试的最大学生数</a><br /><br /> <img alt="image-20231227214129434" src="D:\typora笔记\动态规划.assets\image-20231227214129434.png" /><br /><br />1001快速得到上一排的作为要求1001 1000 001 0000<br /><br />```c<br />for (int i = 0; i < m; ++i) // 遍历每一行<br />    for (int l = 0; l < (1 << n); ++l) // 遍历上一行的所有状态<br />        for (int c = 0; c < (1 << n); ++c) // 遍历当前行的所有状态<br /><br />```<br /><br /><br /><br /><strong>c这个状态是表示这一排学生坐的状态，把从0到1<<n的都遍历了一遍，首先就通过c&&(1<<j)来判断是否这个j安排人坐，然后再通过这个位置是不是有座位</strong><br /><br /><br /><br />在最内层循环中，使用一系列条件判断来检查当前座位状态是否合法，即是否可以让学生坐在这个位置。主要的条件包括：<br /><br />- 座位没有被占用<br />- 左上、右上、左侧、右侧、左上、右上、左下、右下都没有其他学生（即相邻位置没有学生）<br /><br />`if (!(c & (1 << j))) continue;` 这行代码用于检查座位状态 `c` 中的第 `j` 位是否为 0。如果为 0，表示在当前座位状态下，第 `j` 个座位是空的（没有学生坐在上面），那么 `continue` 将会跳过当前循环，不再执行后续的代码。<br /><br />这个检查的目的是在处理当前座位状态时，只关注空座位，而忽略已经被占用的座位。如果第 `j` 位为 1，表示座位被占用，那么 `continue` 就不会执行，继续执行后续的代码。<br /><br />在这个程序中，这行代码用于确保当前考虑的座位状态 `c` 中，只有空座位才会被进一步考虑，而被占用的座位将被跳过。这有助于在动态规划过程中筛选出合法的座位状态。<br /><br />假设有一个座位状态 `c`，它是一个二进制数，例如 `c = 10101`，表示座位状态为有座位（1）和空座位（0）交替排列。<br /><br />现在，假设我们希望检查第 2 位（从右到左，从 0 开始计数）是否为 0，即检查 `c` 中的第 2 位是否是空座位。我们可以使用位运算来实现这一检查：<br /><br />```<br />int j = 2; // 第 2 位<br />if (!(c & (1 << j))) {<br />    // 如果第 2 位是 0（空座位），则执行以下代码<br />    // ...<br />} else {<br />    // 如果第 2 位是 1（座位被占用），则执行其他操作或跳过<br />    // ...<br />}<br />```<br /><br />在这个例子中，`c & (1 << j)` 表示将 `1` 左移 `j` 位，然后与 `c` 进行按位与运算。如果结果为 0，说明第 `j` 位是空座位，就会进入 `if` 语句中的代码块。如果结果不为 0，说明第 `j` 位是被占用的座位，就会执行 `else` 语句中的代码块。<br /><br />这样，通过 `if (!(c & (1 << j))) continue;` 这行代码，可以确保在处理当前座位状态时，只考虑空座位，而跳过已被占用的座位。<br /><br /><img alt="image-20231228152158623" src="D:\typora笔记\动态规划.assets\image-20231228152158623.png" /><br /><br />```c++<br />class Solution {<br />public:<br />    int count(int n)<br />    {<br />        int res = 0;<br />        while(n != 0)<br />        {<br />            n = n & (n-1);<br />            res++;<br />        }<br />        return res;<br />    }<br />    int maxStudents(vector<vector<char>>& seats) {<br />        int m = seats.size();<br />        int n = seats[0].size();<br />        vector<vector<int>> dp(m + 1, vector<int>(1<<n));<br />        for(int i=0;i<m;++i)<br />        {<br />            for(int l=0;l<(1 << n); ++l)<br />                for(int c = 0 ; c < (1<<n);++c)<br />                {<br />                    bool flag = true;<br />                    for(int j=0;j<n&&flag;++j) {<br />                        if(!(c&(1<<j))) continue;<br />                        if(seats[i][j]=='#') flag = false;<br />                        bool lt = j==0 ? false : (c&(1<<(j-1)));<br />                        bool rt = j==n-1? false : (c&(1<<(j+1)));<br />                        bool ul = (j==0||i==0)? false:(l&(1<<(j-1)));<br />                        bool ur = (j==n-1||i==0)? false:(l&(1<<(j+1)));<br />                        if(lt||rt||ul||ur) flag = false;<br />                    }<br />                    if(flag)<br />                     dp[i+1][c] = max(dp[i+1][c],dp[i][l]+count(c));<br />                }<br />        }<br />        return *max_element(begin(dp[m]),end(dp[m]));<br />    }<br />};<br />```<br /><br /></p>
            </main>
            
            <!-- 文章底部 -->
            <footer class="post-footer">
                <div class="post-actions">
                    <button class="back-button" onclick="history.back()">← 返回上页</button>
                    <a href="../../blog.html" class="more-posts-link">查看更多文章 →</a>
                </div>
                
                <!-- 文章标签 -->
                <div class="post-tags">
                    <span class="tag-label">标签：</span>
                    <span class="tag">算法</span>
                </div>
                
                <!-- 版权信息 -->
                <div class="post-copyright">
                    <p>本文由技术博客原创，转载请注明出处。欢迎分享与交流！</p>
                </div>
            </footer>
        </article>
    </div>

    <!-- JavaScript文件 -->
    <script src="../../scripts/highlight.js"></script>
    <script src="../../scripts/reading-toolbar.js"></script>
    <script src="../../scripts/table-of-contents.js"></script>
    
    <!-- 页面性能监控 -->
    <script>
        // 简单的页面加载性能监控
        window.addEventListener('load', function() {
            const loadTime = window.performance.timing.loadEventEnd - window.performance.timing.navigationStart;
            console.log('页面加载时间:', loadTime + 'ms');
        });
    </script>
</body>
</html>