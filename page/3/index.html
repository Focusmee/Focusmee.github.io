<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/3/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Gemini',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://example.com/page/3/"/>





  <title>Hexo</title>
  














<meta name="generator" content="Hexo 7.3.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/02/07/%E3%80%90Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E3%80%91nil%E5%88%87%E7%89%87%E4%B8%8E%E7%A9%BA%E5%88%87%E7%89%87%EF%BC%9A%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E4%B8%8E%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8%E6%8C%87%E5%8D%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/02/07/%E3%80%90Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E3%80%91nil%E5%88%87%E7%89%87%E4%B8%8E%E7%A9%BA%E5%88%87%E7%89%87%EF%BC%9A%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E4%B8%8E%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8%E6%8C%87%E5%8D%97/" itemprop="url">Go语言中的nil切片与空切片：深入解析与实际应用指南</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-02-07T16:00:10+08:00">
                2025-02-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="一、核心概念解析"><a href="#一、核心概念解析" class="headerlink" title="一、核心概念解析"></a>一、核心概念解析</h2><h3 id="1-1-nil切片"><a href="#1-1-nil切片" class="headerlink" title="1.1 nil切片"></a>1.1 nil切片</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s []<span class="type">int</span>        <span class="comment">// nil切片</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>底层结构</strong>：无底层数组指针</li>
<li><strong>长度&#x2F;容量</strong>：0</li>
<li><strong>判断方式</strong>：<code>s == nil</code> 返回true</li>
<li><strong>内存分配</strong>：不占用堆内存</li>
</ul>
<h3 id="1-2-空切片"><a href="#1-2-空切片" class="headerlink" title="1.2 空切片"></a>1.2 空切片</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s1 := []<span class="type">int</span>&#123;&#125;       <span class="comment">// 字面量创建</span></span><br><span class="line">s2 := <span class="built_in">make</span>([]<span class="type">int</span>,<span class="number">0</span>) <span class="comment">// make创建</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>底层结构</strong>：指向空数组的指针</li>
<li><strong>长度&#x2F;容量</strong>：0</li>
<li><strong>内存分配</strong>：占用极小堆内存（约24字节）</li>
</ul>
<p><img src="https://example.com/slice-memory.png" alt="nil切片与空切片内存结构对比"></p>
<h2 id="二、关键差异对比"><a href="#二、关键差异对比" class="headerlink" title="二、关键差异对比"></a>二、关键差异对比</h2><table>
<thead>
<tr>
<th>特性</th>
<th>nil切片</th>
<th>空切片</th>
</tr>
</thead>
<tbody><tr>
<td>底层数组</td>
<td>无</td>
<td>有空数组</td>
</tr>
<tr>
<td>内存占用</td>
<td>0</td>
<td>~24字节</td>
</tr>
<tr>
<td>JSON序列化</td>
<td>null</td>
<td>[]</td>
</tr>
<tr>
<td>函数参数行为</td>
<td>可被修改为nil</td>
<td>始终非nil</td>
</tr>
<tr>
<td>append操作</td>
<td>自动创建新数组</td>
<td>直接追加到空数组</td>
</tr>
</tbody></table>
<h2 id="三、典型示例解析"><a href="#三、典型示例解析" class="headerlink" title="三、典型示例解析"></a>三、典型示例解析</h2><h3 id="3-1-问题切片s4分析"><a href="#3-1-问题切片s4分析" class="headerlink" title="3.1 问题切片s4分析"></a>3.1 问题切片s4分析</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s4 := []<span class="type">int</span>&#123;<span class="number">1</span>&#125;     <span class="comment">// 初始化长度1，容量1</span></span><br><span class="line">s4 = s4[:<span class="number">0</span>]        <span class="comment">// 截取后长度0，容量1</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>底层数组</strong>：仍然存在，容量保持1</li>
<li><strong>内存表现</strong>：数组[1]仍在内存中</li>
<li><strong>操作特性</strong>：后续append无需重新分配内存</li>
</ul>
<h3 id="3-2-切片操作对容量的影响"><a href="#3-2-切片操作对容量的影响" class="headerlink" title="3.2 切片操作对容量的影响"></a>3.2 切片操作对容量的影响</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr := [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line">s := arr[<span class="number">1</span>:<span class="number">3</span>]      <span class="comment">// len=2, cap=4</span></span><br><span class="line">s = s[:<span class="number">0</span>]          <span class="comment">// len=0, cap=4</span></span><br></pre></td></tr></table></figure>

<h2 id="四、面试高频考点"><a href="#四、面试高频考点" class="headerlink" title="四、面试高频考点"></a>四、面试高频考点</h2><h3 id="4-1-常见面试题"><a href="#4-1-常见面试题" class="headerlink" title="4.1 常见面试题"></a>4.1 常见面试题</h3><ol>
<li><p>以下代码输出什么？</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s []<span class="type">int</span></span><br><span class="line">fmt.Println(s[<span class="number">0</span>:<span class="number">0</span>] == <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure>
<p>答案：false（切片操作产生空切片）</p>
</li>
<li><p>如何高效清空切片？</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = s[:<span class="number">0</span>]          <span class="comment">// 保留容量（适合重用）</span></span><br><span class="line">s = <span class="literal">nil</span>            <span class="comment">// 释放内存（适合不再使用）</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>函数返回空切片时更推荐哪种方式？</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="keyword">return</span> []<span class="type">int</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br></pre></td></tr></table></figure>
<p>原因：避免调用方需要处理nil判断</p>
</li>
</ol>
<h3 id="4-2-易错点分析"><a href="#4-2-易错点分析" class="headerlink" title="4.2 易错点分析"></a>4.2 易错点分析</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">process</span><span class="params">(s []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    s = <span class="built_in">append</span>(s, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> s []<span class="type">int</span>    <span class="comment">// nil切片</span></span><br><span class="line">    process(s)</span><br><span class="line">    fmt.Println(s) <span class="comment">// 输出[]而不是[1]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>原理</strong>：append操作产生新切片，原始指针未修改</p>
<h2 id="五、实际应用指南"><a href="#五、实际应用指南" class="headerlink" title="五、实际应用指南"></a>五、实际应用指南</h2><h3 id="5-1-最佳实践"><a href="#5-1-最佳实践" class="headerlink" title="5.1 最佳实践"></a>5.1 最佳实践</h3><ol>
<li><p><strong>初始化选择</strong>：</p>
<ul>
<li>预期后续填充数据 → <code>make([]T, 0, capacity)</code></li>
<li>可能不使用的切片 → <code>var s []T</code></li>
</ul>
</li>
<li><p><strong>API设计原则</strong>：</p>
<ul>
<li>返回空切片而非nil，除非需要特殊语义</li>
<li>接收切片参数时应处理nil情况</li>
</ul>
</li>
<li><p><strong>性能优化</strong>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 预分配容量避免多次扩容</span></span><br><span class="line">users := <span class="built_in">make</span>([]User, <span class="number">0</span>, <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 大切片及时置nil帮助GC</span></span><br><span class="line">bigData := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">1e8</span>)</span><br><span class="line"><span class="comment">// 使用完成后...</span></span><br><span class="line">bigData = <span class="literal">nil</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="5-2-典型应用场景"><a href="#5-2-典型应用场景" class="headerlink" title="5.2 典型应用场景"></a>5.2 典型应用场景</h3><ol>
<li><p><strong>缓存池实现</strong>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pool []*Buffer</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getBuffer</span><span class="params">()</span></span> *Buffer &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(pool) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">new</span>(Buffer)</span><br><span class="line">    &#125;</span><br><span class="line">    b := pool[<span class="built_in">len</span>(pool)<span class="number">-1</span>]</span><br><span class="line">    pool = pool[:<span class="built_in">len</span>(pool)<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>高效数据重置</strong>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Request <span class="keyword">struct</span> &#123;</span><br><span class="line">    headers []Header</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Request)</span></span> Reset() &#123;</span><br><span class="line">    r.headers = r.headers[:<span class="number">0</span>]  <span class="comment">// 保留底层数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="六、深度理解延伸"><a href="#六、深度理解延伸" class="headerlink" title="六、深度理解延伸"></a>六、深度理解延伸</h2><h3 id="6-1-切片本质结构"><a href="#6-1-切片本质结构" class="headerlink" title="6.1 切片本质结构"></a>6.1 切片本质结构</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span> &#123;</span><br><span class="line">    array unsafe.Pointer</span><br><span class="line">    <span class="built_in">len</span>   <span class="type">int</span></span><br><span class="line">    <span class="built_in">cap</span>   <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>nil切片：array指针为nil</li>
<li>空切片：array指向空数组</li>
</ul>
<h3 id="6-2-内存分配模式"><a href="#6-2-内存分配模式" class="headerlink" title="6.2 内存分配模式"></a>6.2 内存分配模式</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 产生堆分配</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newSlice</span><span class="params">()</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可能栈分配（编译器优化）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">stackSlice</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">10</span>)</span><br><span class="line">    _ = s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="七、总结与建议"><a href="#七、总结与建议" class="headerlink" title="七、总结与建议"></a>七、总结与建议</h2><p><strong>关键收获</strong>：</p>
<ul>
<li>nil切片是零值状态，空切片是初始化状态</li>
<li>容量取决于底层数组，与当前长度无关</li>
<li>合理选择初始化方式能提升性能和代码健壮性</li>
</ul>
<p><strong>开发建议</strong>：</p>
<ol>
<li>明确区分”无数据”和”空数据”的语义</li>
<li>大切片及时置nil帮助内存回收</li>
<li>公共API优先返回空切片</li>
<li>高频操作切片考虑复用底层数组</li>
</ol>
<p>通过深入理解切片机制，开发者可以写出更高效、健壮的Go语言代码，在内存管理和性能优化方面做出更明智的决策。</p>
<h2 id="八、测试代码"><a href="#八、测试代码" class="headerlink" title="八、测试代码"></a>八、测试代码</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> s1 []<span class="type">int</span>         <span class="comment">// nil 切片</span></span><br><span class="line">	s2 := []<span class="type">int</span>&#123;&#125;        <span class="comment">// 空切片</span></span><br><span class="line">	s3 := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>) <span class="comment">// 空切片</span></span><br><span class="line">	s4 := []<span class="type">int</span>&#123;<span class="number">1</span>&#125;</span><br><span class="line">	s4 = s4[:<span class="number">0</span>]</span><br><span class="line">	fmt.Println(s1 == <span class="literal">nil</span>) <span class="comment">// 输出: true</span></span><br><span class="line">	fmt.Println(s2 == <span class="literal">nil</span>) <span class="comment">// 输出: false</span></span><br><span class="line">	fmt.Println(s3 == <span class="literal">nil</span>) <span class="comment">// 输出: false</span></span><br><span class="line">	fmt.Println(s4 == <span class="literal">nil</span>) <span class="comment">// 输出: false</span></span><br><span class="line"></span><br><span class="line">	fmt.Println(s1, <span class="built_in">len</span>(s1), <span class="built_in">cap</span>(s1)) <span class="comment">// 输出: [] 0 0</span></span><br><span class="line">	fmt.Println(s2, <span class="built_in">len</span>(s2), <span class="built_in">cap</span>(s2)) <span class="comment">// 输出: [] 0 0</span></span><br><span class="line">	fmt.Println(s3, <span class="built_in">len</span>(s3), <span class="built_in">cap</span>(s3)) <span class="comment">// 输出: [] 0 0</span></span><br><span class="line">	fmt.Println(s3, <span class="built_in">len</span>(s4), <span class="built_in">cap</span>(s4)) <span class="comment">// 输出: [] 0 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="九、切片练习"><a href="#九、切片练习" class="headerlink" title="九、切片练习"></a>九、切片练习</h2><h3 id="如何实现-Pic。它应当返回一个长度为-dy-的切片，其中每个元素是一个长度为-dx，元素类型为-uint8-的切片？"><a href="#如何实现-Pic。它应当返回一个长度为-dy-的切片，其中每个元素是一个长度为-dx，元素类型为-uint8-的切片？" class="headerlink" title="如何实现 Pic。它应当返回一个长度为 dy 的切片，其中每个元素是一个长度为 dx，元素类型为 uint8 的切片？"></a>如何实现 <code>Pic</code>。它应当返回一个长度为 <code>dy</code> 的切片，其中每个元素是一个长度为 <code>dx</code>，元素类型为 <code>uint8</code> 的切片？</h3><h4 id="思路分析："><a href="#思路分析：" class="headerlink" title="思路分析："></a>思路分析：</h4><p><code>make</code> 函数会分配一个元素为零值的数组并返回一个引用了它的切片</p>
<p>在Go中，二维切片通常通过两层make来创建。首先外层切片需要用make初始化长度为dy，然后每个内层切片也需要分别初始化为长度dx的uint8切片。</p>
<p>可能的实现方式是先创建一个长度为dy的[][]uint8切片，然后遍历每个元素，为每个位置分配一个长度为dx的[]uint8。或者，使用循环来初始化每个内层切片。需要注意的是，如果直接使用make([][]uint8, dy)，内层的每个切片会是nil，必须单独初始化。</p>
<p>另外，有没有更高效的方法？比如，在初始化外层切片的同时，预分配每个内层切片。例如，使用一个循环，每次创建一个新的uint8切片，然后赋值给外层切片的对应位置。这样可以确保每个内层切片都被正确初始化，而不是nil。</p>
<p>还需要考虑边界情况，比如dy或dx为0时，应该返回空的切片，而不会引发错误。此外，每个内层切片的元素默认是0值，符合uint8的初始值。</p>
<p>在 Go 语言中创建二维切片可通过以下方式实现：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Create2DUint8</span><span class="params">(dy, dx <span class="type">int</span>)</span></span> [][]<span class="type">uint8</span> &#123;</span><br><span class="line">    <span class="comment">// 创建外层切片</span></span><br><span class="line">    matrix := <span class="built_in">make</span>([][]<span class="type">uint8</span>, dy)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化每个内层切片</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> matrix &#123;</span><br><span class="line">        matrix[i] = <span class="built_in">make</span>([]<span class="type">uint8</span>, dx)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> matrix</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="关键解析："><a href="#关键解析：" class="headerlink" title="关键解析："></a>关键解析：</h4><ol>
<li><p><strong>内存分配</strong>：</p>
<ul>
<li><code>make([][]uint8, dy)</code> 创建包含 <code>dy</code> 个元素的切片</li>
<li>每个元素初始化为 <code>nil</code>（需要二次初始化）</li>
</ul>
</li>
<li><p><strong>性能优化</strong>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 预分配所有内存（推荐）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Create2DUint8Optimized</span><span class="params">(dy, dx <span class="type">int</span>)</span></span> [][]<span class="type">uint8</span> &#123;</span><br><span class="line">    flat := <span class="built_in">make</span>([]<span class="type">uint8</span>, dy*dx)</span><br><span class="line">    matrix := <span class="built_in">make</span>([][]<span class="type">uint8</span>, dy)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> matrix &#123;</span><br><span class="line">        matrix[i] = flat[i*dx : (i+<span class="number">1</span>)*dx]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> matrix</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>单次内存分配提升性能</li>
<li>所有行共享底层数组（修改会影响相邻行）</li>
</ul>
</li>
<li><p><strong>零值特性</strong>：</p>
<ul>
<li>所有元素自动初始化为 <code>uint8</code> 的零值（即 0）</li>
</ul>
</li>
</ol>
<h4 id="使用示例："><a href="#使用示例：" class="headerlink" title="使用示例："></a>使用示例：</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 创建 3x4 矩阵</span></span><br><span class="line">    matrix := Create2DUint8(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 赋值演示</span></span><br><span class="line">    matrix[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">255</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出：</span></span><br><span class="line">    <span class="comment">// [</span></span><br><span class="line">    <span class="comment">//   [0 0 0 0],</span></span><br><span class="line">    <span class="comment">//   [0 0 255 0],</span></span><br><span class="line">    <span class="comment">//   [0 0 0 0]</span></span><br><span class="line">    <span class="comment">// ]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="应用场景建议："><a href="#应用场景建议：" class="headerlink" title="应用场景建议："></a>应用场景建议：</h4><ol>
<li><strong>图像处理</strong>：适合表示灰度图像的像素矩阵</li>
<li><strong>游戏开发</strong>：可用于创建二维地图网格</li>
<li><strong>科学计算</strong>：矩阵运算的基础数据结构</li>
</ol>
<h4 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h4><ul>
<li><strong>内存布局</strong>：常规方式每行独立分配，优化版共享内存</li>
<li><strong>并发安全</strong>：共享底层数组时需注意并发写冲突</li>
<li><strong>大矩阵处理</strong>：当 dx&#x2F;dy &gt; 1e4 时建议使用优化版本</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/02/05/%E3%80%90Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E3%80%91%E6%95%B0%E5%80%BC%E5%B8%B8%E9%87%8F%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E5%92%8C%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E5%9D%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/02/05/%E3%80%90Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E3%80%91%E6%95%B0%E5%80%BC%E5%B8%B8%E9%87%8F%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E5%92%8C%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E5%9D%91/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-02-05T17:11:33+08:00">
                2025-02-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<h2 id="title-数值常量的类型转换和二进制需要注意的坑"><a href="#title-数值常量的类型转换和二进制需要注意的坑" class="headerlink" title="title:数值常量的类型转换和二进制需要注意的坑"></a>title:数值常量的类型转换和二进制需要注意的坑</h2><h2 id="数值常量"><a href="#数值常量" class="headerlink" title="数值常量"></a>数值常量</h2><p>数值常量是高精度的 <strong>值</strong>。</p>
<p>一个未指定类型的常量由上下文来决定其类型。</p>
<p>源代码是这样的</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	<span class="comment">// 将 1 左移 100 位来创建一个非常大的数字</span></span><br><span class="line">	<span class="comment">// 即这个数的二进制是 1 后面跟着 100 个 0</span></span><br><span class="line">	Big = <span class="number">1</span> &lt;&lt; <span class="number">100</span></span><br><span class="line">	<span class="comment">// 再往右移 99 位，即 Small = 1 &lt;&lt; 1，或者说 Small = 2</span></span><br><span class="line">	Small = Big &gt;&gt; <span class="number">99</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">needInt</span><span class="params">(x <span class="type">int</span>)</span></span> <span class="type">int</span> &#123; <span class="keyword">return</span> x*<span class="number">10</span> + <span class="number">1</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">needFloat</span><span class="params">(x <span class="type">float64</span>)</span></span> <span class="type">float64</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> x * <span class="number">0.1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(needInt(Small))</span><br><span class="line">	fmt.Println(needFloat(Small))</span><br><span class="line">	fmt.Println(needFloat(Big))</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后突发奇想试试63测试边界，但是直接报错</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./prog.go:19:15: cannot use Big (untyped int constant 9223372036854775808) as int value in argument to fmt.Println (overflows)</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	Big = <span class="number">1</span> &lt;&lt; <span class="number">63</span></span><br><span class="line">	Small = Big &gt;&gt; <span class="number">99</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">needInt</span><span class="params">(x <span class="type">int</span>)</span></span> <span class="type">int</span> &#123; <span class="keyword">return</span> x*<span class="number">10</span> + <span class="number">1</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">needFloat</span><span class="params">(x <span class="type">float64</span>)</span></span> <span class="type">float64</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> x * <span class="number">0.1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(needInt(Small))</span><br><span class="line">	fmt.Println(needFloat(Small))</span><br><span class="line">	fmt.Println(needFloat(Big))</span><br><span class="line">	 fmt.Println(Big)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这是因为Go 中的常量是 <strong>无类型的</strong>（untyped），会根据使用的上下文来推断类型。在 <code>1 &lt;&lt; 63</code> 这种表达式中，由于它是一个非常大的数字，Go 会推导它为 <code>untyped int constant</code>，这会导致溢出错误。当你尝试将其赋给 <code>int64</code> 时，编译器会认为它超出了 <code>int64</code> 类型的范围，导致错误。</p>
<p>而如果想要得到-9223372036854775808，也就是1作为符号位，就要</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Big2 <span class="type">int64</span> = -(<span class="number">1</span>&lt;&lt;<span class="number">63</span>)</span><br></pre></td></tr></table></figure>

<p>手动添加符号</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/02/05/%E3%80%90Go%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF%E3%80%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/02/05/%E3%80%90Go%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF%E3%80%91/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-02-05T13:33:16+08:00">
                2025-02-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<h2 id="title-Go语言学习打卡"><a href="#title-Go语言学习打卡" class="headerlink" title="title:Go语言学习打卡"></a>title:Go语言学习打卡</h2><p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/xuexiluxian/go-7.jpg" alt="Go 语言的学习路线图"></p>
<ul>
<li><input disabled="" type="checkbox"> 每天刷十道算法</li>
<li><input disabled="" type="checkbox"> 月底做完一个gin项目</li>
<li><input disabled="" type="checkbox"> 计网八股</li>
<li><input disabled="" type="checkbox"> 数据库八股</li>
<li><input disabled="" type="checkbox"> go八股星球八股+手动面经整理+面试整理+小林Coding</li>
<li><input disabled="" type="checkbox"> java数据库搭建（26日）</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/02/05/%E3%80%90Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E3%80%91const%E5%92%8Citoa/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/02/05/%E3%80%90Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E3%80%91const%E5%92%8Citoa/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-02-05T12:49:24+08:00">
                2025-02-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<h2 id="title-const和itoa"><a href="#title-const和itoa" class="headerlink" title="title:const和itoa"></a>title:const和itoa</h2><p><strong>const 用于定义常量，定义之后不能修改，不能再次赋值，在程序运行期间不会改变。</strong></p>
<h1 id="定义一个常量"><a href="#定义一个常量" class="headerlink" title="定义一个常量"></a>定义一个常量</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> pi = <span class="number">3.1415926</span></span><br></pre></td></tr></table></figure>

<h1 id="批量声明常量"><a href="#批量声明常量" class="headerlink" title="批量声明常量"></a>批量声明常量</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">   statusOk = <span class="number">200</span></span><br><span class="line">   notFound = <span class="number">404</span></span><br><span class="line">   serverError = <span class="number">500</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h1 id="批量声明常量时，如果某一行没有写-，那么就和上一行一致"><a href="#批量声明常量时，如果某一行没有写-，那么就和上一行一致" class="headerlink" title="批量声明常量时，如果某一行没有写&#x3D;，那么就和上一行一致"></a>批量声明常量时，如果某一行没有写&#x3D;，那么就和上一行一致</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">   n1 = <span class="number">100</span></span><br><span class="line">   n2</span><br><span class="line">   n3</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>打印结果：n1 n2 n3 都是100</p>
<h1 id="iota"><a href="#iota" class="headerlink" title="iota"></a>iota</h1><ol>
<li>在const关键字出现时将被重置为0；</li>
<li>const中每增加一行常量声明，将使 iota 计数一次</li>
<li>我iota的理解就是类似枚举</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">const</span> (</span><br><span class="line">   a1 = <span class="literal">iota</span> <span class="comment">//0</span></span><br><span class="line">   a2</span><br><span class="line">   a3</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>打印结果：a1:0 a2:1 a3:2</p>
<h2 id="iota面试题1"><a href="#iota面试题1" class="headerlink" title="iota面试题1"></a>iota面试题1</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span>  <span class="keyword">const</span> (</span><br><span class="line">   b1 = <span class="literal">iota</span> <span class="comment">//0</span></span><br><span class="line">   b2        <span class="comment">//1</span></span><br><span class="line">   _         <span class="comment">//2</span></span><br><span class="line">   b3        <span class="comment">//3</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><strong>分析：_也占了一行，所以_的值相当于是2，打印b3的值为3</strong></p>
<h2 id="iota面试题2：插队情况-1"><a href="#iota面试题2：插队情况-1" class="headerlink" title="iota面试题2：插队情况(1)"></a>iota面试题2：插队情况(1)</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span>  <span class="keyword">const</span> (</span><br><span class="line">   c1 = <span class="literal">iota</span> <span class="comment">//0</span></span><br><span class="line">   c2 = <span class="number">100</span>  <span class="comment">//100</span></span><br><span class="line">   c3        <span class="comment">//100</span></span><br><span class="line">   c4        <span class="comment">//100</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><strong>分析：c1&#x3D;iota，所以c1的值为0很好理解；因为c2&#x3D;100，而c3、c4没有&#x3D;，所以和c2的值保持一致都是100</strong></p>
<h2 id="iota面试题3：插队情况-2"><a href="#iota面试题3：插队情况-2" class="headerlink" title="iota面试题3：插队情况(2)"></a>iota面试题3：插队情况(2)</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">const</span> (</span><br><span class="line">   d1 = <span class="literal">iota</span> <span class="comment">//0</span></span><br><span class="line">   d2 = <span class="number">100</span>  <span class="comment">//100</span></span><br><span class="line">   d3 = <span class="literal">iota</span> <span class="comment">//2</span></span><br><span class="line">   d4        <span class="comment">//3</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><strong>分析：d3的值为2可能出乎有些同学的意料，有的同学可能觉得d3的值为0，其实不是的。这道题其实就是为了让d3继续使用iota的方式设置值。 或者这么讲：在面试题2中怎么设置让c3不为100，而是继续按照iota赋值，让c3&#x3D;2呢？面试题3就给出了答案。</strong></p>
<h2 id="多个常量声明在一行"><a href="#多个常量声明在一行" class="headerlink" title="多个常量声明在一行"></a>多个常量声明在一行</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">const</span> (</span><br><span class="line">   d1, d2 = <span class="literal">iota</span> + <span class="number">1</span>, <span class="literal">iota</span> + <span class="number">2</span> <span class="comment">//1 2</span></span><br><span class="line">   d3, d4 = <span class="literal">iota</span> + <span class="number">1</span>, <span class="literal">iota</span> + <span class="number">2</span> <span class="comment">//2 3</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><strong>分析：其实很好理解，第一行的iota值为0，第二行的iota值为1，再执行加法运算就是注释中标注的结果了</strong></p>
<h1 id="iota应用实例"><a href="#iota应用实例" class="headerlink" title="iota应用实例"></a>iota应用实例</h1><h3 id="1-基本枚举"><a href="#1-基本枚举" class="headerlink" title="1. 基本枚举"></a><strong>1. 基本枚举</strong></h3><p>定义一组自增的枚举常量：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const (</span><br><span class="line">    Pending = iota // 0</span><br><span class="line">    Active         // 1</span><br><span class="line">    Done           // 2</span><br><span class="line">)</span><br></pre></td></tr></table></figure>



<h3 id="2-结合表达式"><a href="#2-结合表达式" class="headerlink" title="2. 结合表达式"></a><strong>2. 结合表达式</strong></h3><p>生成带有偏移或运算的常量：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    A = <span class="literal">iota</span> + <span class="number">1</span>   <span class="comment">// 1</span></span><br><span class="line">    B              <span class="comment">// 2</span></span><br><span class="line">    C              <span class="comment">// 3</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结合位运算（权限控制）</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    Read  = <span class="number">1</span> &lt;&lt; <span class="literal">iota</span> <span class="comment">// 1 (0b001)</span></span><br><span class="line">    Write             <span class="comment">// 2 (0b010)</span></span><br><span class="line">    Exec              <span class="comment">// 4 (0b100)</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>



<h3 id="3-跳过特定值"><a href="#3-跳过特定值" class="headerlink" title="3. 跳过特定值"></a><strong>3. 跳过特定值</strong></h3><p>使用<code>_</code>忽略某些值：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    Apple = <span class="literal">iota</span> <span class="comment">// 0</span></span><br><span class="line">    Banana       <span class="comment">// 1</span></span><br><span class="line">    _            <span class="comment">// 2（跳过）</span></span><br><span class="line">    Cherry       <span class="comment">// 3</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>



<h3 id="4-文件大小单位"><a href="#4-文件大小单位" class="headerlink" title="4. 文件大小单位"></a><strong>4. 文件大小单位</strong></h3><p>生成按指数增长的常量（如KB、MB）：</p>
<p>定义数量级</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">const</span> (</span><br><span class="line">   _  = <span class="literal">iota</span></span><br><span class="line">   KB = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>)</span><br><span class="line">   MB = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>)</span><br><span class="line">   GB = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>)</span><br><span class="line">   TB = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>)</span><br><span class="line">   PB = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">KB: <span class="number">1024</span></span><br><span class="line">MB: <span class="number">1048576</span></span><br><span class="line">GB: <span class="number">1073741824</span></span><br><span class="line">TB: <span class="number">1099511627776</span></span><br><span class="line">PB: <span class="number">1125899906842624</span></span><br></pre></td></tr></table></figure>

<h5 id="更进一步"><a href="#更进一步" class="headerlink" title="更进一步"></a>更进一步</h5><p>猜一下下面代码段的输出结果是什么？</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">const</span> (</span><br><span class="line">   _  = <span class="literal">iota</span></span><br><span class="line">   KB = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>)</span><br><span class="line">   MB</span><br><span class="line">   GB</span><br><span class="line">   TB</span><br><span class="line">   PB</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>打印结果和上面是一样的：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/08f340a4fef847949e36c1c2997fae35~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="image.png"></p>
<h3 id="5-索引常量"><a href="#5-索引常量" class="headerlink" title="5. 索引常量"></a><strong>5. 索引常量</strong></h3><p>为数组或结构体字段生成索引：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    Name = <span class="literal">iota</span> <span class="comment">// 0</span></span><br><span class="line">    Age         <span class="comment">// 1</span></span><br><span class="line">    Email       <span class="comment">// 2</span></span><br><span class="line">    NumFields   <span class="comment">// 3（字段总数）</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> user [NumFields]<span class="type">string</span></span><br></pre></td></tr></table></figure>



<h3 id="6-多常量分组"><a href="#6-多常量分组" class="headerlink" title="6. 多常量分组"></a><strong>6. 多常量分组</strong></h3><p>不同<code>const</code>块中的<code>iota</code>独立计数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ( <span class="comment">// 分组1</span></span><br><span class="line">    GroupA = <span class="literal">iota</span> <span class="comment">// 0</span></span><br><span class="line">    GroupB        <span class="comment">// 1</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ( <span class="comment">// 分组2</span></span><br><span class="line">    GroupX = <span class="literal">iota</span> <span class="comment">// 0</span></span><br><span class="line">    GroupY        <span class="comment">// 1</span></span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="7-字符串枚举"><a href="#7-字符串枚举" class="headerlink" title="7. 字符串枚举"></a><strong>7. 字符串枚举</strong></h3><p>结合字符串方法生成可读枚举：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Status <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    Pending Status = <span class="literal">iota</span></span><br><span class="line">    Active</span><br><span class="line">    Completed</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Status)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> [...]<span class="type">string</span>&#123;<span class="string">&quot;Pending&quot;</span>, <span class="string">&quot;Active&quot;</span>, <span class="string">&quot;Completed&quot;</span>&#125;[s]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="8-复杂表达式"><a href="#8-复杂表达式" class="headerlink" title="8. 复杂表达式"></a><strong>8. 复杂表达式</strong></h3><p>同一行声明多个常量：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    A, B = <span class="literal">iota</span>, <span class="literal">iota</span> * <span class="number">2</span> <span class="comment">// A=0, B=0</span></span><br><span class="line">    C, D                  <span class="comment">// C=1, D=2</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a><strong>注意事项</strong></h3><ul>
<li><p><code>iota</code>在<code>const</code>块中从0开始，每行递增，<strong>无论是否显式使用</strong>。</p>
</li>
<li><p>中断<code>iota</code>后需显式恢复：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    A = <span class="literal">iota</span>    <span class="comment">// 0</span></span><br><span class="line">    B           <span class="comment">// 1</span></span><br><span class="line">    C = <span class="number">100</span>     <span class="comment">// 100（显式赋值）</span></span><br><span class="line">    D = <span class="literal">iota</span>    <span class="comment">// 3（继续递增）</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>定义常量使用<code>const</code>关键字，定义之后不能修改，不能再次赋值，在程序运行期间不会改变。</p>
<p><code>iota</code>是go语言中很特殊的设定，<code>iota</code>主要用于简化自增常量的声明，适合枚举、位掩码、索引等场景。使用时需注意其递增规则，避免因中断或复杂表达式导致意外结果。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/02/04/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E3%80%91Acwing%E7%9A%84%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/02/04/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E3%80%91Acwing%E7%9A%84%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-02-04T15:57:04+08:00">
                2025-02-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<h2 id="title-Acwing的基础算法"><a href="#title-Acwing的基础算法" class="headerlink" title="title:Acwing的基础算法"></a>title:Acwing的基础算法</h2><p><img src="D:\typora笔记\基础算法.assets\image-20231227203029359.png" alt="image-20231227203029359"></p>
<h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = l - <span class="number">1</span>, j = r + <span class="number">1</span>, x = q[l + r &gt;&gt; <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">do</span> i ++ ; <span class="keyword">while</span> (q[i] &lt; x);</span><br><span class="line">        <span class="keyword">do</span> j -- ; <span class="keyword">while</span> (q[j] &gt; x);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) <span class="built_in">swap</span>(q[i], q[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">quick_sort</span>(q, l, j), <span class="built_in">quick_sort</span>(q, j + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意一下边界问题</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/SHU15121856/article/details/109839618">(48条消息) 【算法学习笔记】8：快速排序中的边界问题_LauZyHou的博客-CSDN博客_快速排序边界问题</a></p>
<h4 id="高精度乘法"><a href="#高精度乘法" class="headerlink" title="高精度乘法"></a>高精度乘法</h4><p>t&#x3D;0;</p>
<p>循环到A.size()||t</p>
<p>本位 C<del>n</del>&#x3D;（A[n]*B+t<del>n-1</del>）%10</p>
<p>给下一位进位 t<del>n+1</del>&#x3D;（A[n]*B）&#x2F;10</p>
<h4 id="前缀和与差分"><a href="#前缀和与差分" class="headerlink" title="前缀和与差分"></a>前缀和与差分</h4><p>前缀和是输出原序列中从第 l个数到第 r个数的和（求出某个区间的和）</p>
<p>差分是将序列中某个区间 <code>[l,r] </code>之间的每个数加上一个数。</p>
<p>​	差分关键：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void insert(int l,int r,int c)&#123;</span><br><span class="line">    a[l]+=c;</span><br><span class="line">    a[r+1]-=c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先把每个数字放进去，使得数组a的每个前缀和仍为0</p>
<p>后在插入区间内求出前缀和就完成在区间加上一个数</p>
<h4 id="二进制算法"><a href="#二进制算法" class="headerlink" title="二进制算法"></a>二进制算法</h4><ol>
<li><p>第n位是1还是0 x&gt;&gt;n&amp;1</p>
</li>
<li><p>取得末端第一个是1以及后面的位</p>
<p>例子：比如 5 101 得到的是1 8 1000 得到的是1000</p>
<p>lowbit就是x&amp;-x -x为~x+1（-x为x取反然后+1）</p>
<p>可以通过lowbit知道数字二进制形式有多少个1</p>
</li>
</ol>
<h4 id="单链表："><a href="#单链表：" class="headerlink" title="单链表："></a>单链表：</h4><p>一般用邻接表 存储树和图</p>
<h4 id="双链表："><a href="#双链表：" class="headerlink" title="双链表："></a>双链表：</h4><p>优化某些问题 e[N]表示某个值 ne[N]表示某个点的next指针 通过下标关联起来 空结点ne用-1表示</p>
<h4 id="栈："><a href="#栈：" class="headerlink" title="栈："></a>栈：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// tt表示栈顶</span><br><span class="line">int stk[N], tt = 0;</span><br><span class="line"></span><br><span class="line">// 向栈顶插入一个数</span><br><span class="line">stk[ ++ tt] = x;</span><br><span class="line"></span><br><span class="line">// 从栈顶弹出一个数</span><br><span class="line">tt -- ;</span><br><span class="line"></span><br><span class="line">// 栈顶的值</span><br><span class="line">stk[tt];</span><br><span class="line"></span><br><span class="line">// 判断栈是否为空</span><br><span class="line">if (tt &gt; 0)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="普通队列："><a href="#普通队列：" class="headerlink" title="普通队列："></a>普通队列：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// hh 表示队头，tt表示队尾</span><br><span class="line">int q[N], hh = 0, tt = -1;</span><br><span class="line"></span><br><span class="line">// 向队尾插入一个数</span><br><span class="line">q[ ++ tt] = x;</span><br><span class="line"></span><br><span class="line">// 从队头弹出一个数</span><br><span class="line">hh ++ ;</span><br><span class="line"></span><br><span class="line">// 队头的值</span><br><span class="line">q[hh];</span><br><span class="line"></span><br><span class="line">// 判断队列是否为空</span><br><span class="line">if (hh &lt;= tt)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="循环队列："><a href="#循环队列：" class="headerlink" title="循环队列："></a>循环队列：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// hh 表示队头，tt表示队尾的后一个位置</span><br><span class="line">int q[N], hh = 0, tt = 0;</span><br><span class="line"></span><br><span class="line">// 向队尾插入一个数</span><br><span class="line">q[tt ++ ] = x;</span><br><span class="line">if (tt == N) tt = 0;</span><br><span class="line"></span><br><span class="line">// 从队头弹出一个数</span><br><span class="line">hh ++ ;</span><br><span class="line">if (hh == N) hh = 0;</span><br><span class="line"></span><br><span class="line">// 队头的值</span><br><span class="line">q[hh];</span><br><span class="line"></span><br><span class="line">// 判断队列是否为空</span><br><span class="line">if (hh != tt)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="单调栈："><a href="#单调栈：" class="headerlink" title="单调栈："></a>单调栈：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">常见模型：找出每个数左边离它最近的比它大/小的数</span><br><span class="line">int tt = 0;</span><br><span class="line">for (int i = 1; i &lt;= n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    while (tt &amp;&amp; check(stk[tt], i)) tt -- ;</span><br><span class="line">    stk[ ++ tt] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="单调队列："><a href="#单调队列：" class="headerlink" title="单调队列："></a>单调队列：</h4><ol>
<li>用普通队列该怎么做</li>
<li>将队列中的没有用的元素删掉-&gt;具有了单调性</li>
<li>可以用O(1)时间从队头&#x2F;队尾取出最值</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (i - k + 1 &gt; q[hh]) ++ hh;                  // 若队首出窗口，hh加1</span><br><span class="line">while (hh &lt;= tt &amp;&amp; a[i] &lt;= a[q[tt]]) -- tt;    // 若队尾不单调，tt减1，保证了队头为最小</span><br><span class="line">q[++ tt] = i;                                  // 下标加到队尾，这个元素在后面左窗口缩小的时候可能会成为窗口最凶安置</span><br><span class="line">if (i + 1 &gt;= k) printf(&quot;%d &quot;, a[q[hh]]);       // 输出结果</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\乌拉拉巴卡巴卡\AppData\Roaming\Typora\typora-user-images\image-20230603224710262.png" alt="image-20230603224710262"></p>
<p><img src="C:\Users\乌拉拉巴卡巴卡\AppData\Roaming\Typora\typora-user-images\image-20230603224827020.png" alt="image-20230603224827020"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">常见模型：找出滑动窗口中的最大值/最小值</span><br><span class="line">int hh = 0, tt = -1;</span><br><span class="line">for (int i = 0; i &lt; n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    while (hh &lt;= tt &amp;&amp; check_out(q[hh])) hh ++ ;  // 判断队头是否滑出窗口</span><br><span class="line">    while (hh &lt;= tt &amp;&amp; check(q[tt], i)) tt -- ;</span><br><span class="line">    q[ ++ tt] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h4><p>i和j比较，同则next[i]&#x3D;++j</p>
<p>不同则j看前一个next跳转到新的位置再进行i和j比较</p>
<p>字符串的next数组：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">for(int i=1,j=0;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        while(j&amp;&amp;a[i]!=a[j])</span><br><span class="line">        &#123;</span><br><span class="line">            j=next[j-1];</span><br><span class="line">        &#125;</span><br><span class="line">        if(a[i]==a[j])</span><br><span class="line">        &#123;</span><br><span class="line">            next[i]=j+1;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        if(j==0) next[i]=0,j++;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>对比模式串：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">for(int i=0,j=0;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">          while(j&amp;&amp;a[j]!=b[i]) j=next[j-1];</span><br><span class="line">          if(b[i]==a[j]) </span><br><span class="line">          &#123;</span><br><span class="line">              j++;</span><br><span class="line">          &#125;</span><br><span class="line">          if(j==n)</span><br><span class="line">          &#123;</span><br><span class="line">              j=next[j-1];</span><br><span class="line">              printf(&quot;%d &quot;,i-n+1);</span><br><span class="line">          &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h4 id="Tire树"><a href="#Tire树" class="headerlink" title="Tire树"></a>Tire树</h4><p>需要变量：<code>int son[N][26],cnt[N],id</code></p>
<p>高效地存储和查找字符串</p>
<p>集合的数据结构</p>
<p>每一个出现的结点都会有唯一一个编号idx（也即rxc说的指针）<br>不是按层数来编的，是按出现的先后顺序编的</p>
<p>idx是先把idx自增1再赋值给<code>son[p][u]</code>，而idx是先自增1再赋值给<code>son[p][u]</code>，二者的区别在于，习惯于根节点的编号为0，而存储每一个单词下标是从1开始的，idx++相当于第一个值赋值给了根节点，理解一下这里</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">int son[N][26], cnt[N], idx;</span><br><span class="line">// 0号点既是根节点，又是空节点</span><br><span class="line">// son[][]存储树中每个节点的子节点</span><br><span class="line">// cnt[]存储以每个节点结尾的单词数量</span><br><span class="line"></span><br><span class="line">// 插入一个字符串</span><br><span class="line">void insert(char *str)</span><br><span class="line">&#123;</span><br><span class="line">    int p = 0;</span><br><span class="line">    for (int i = 0; str[i]; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        int u = str[i] - &#x27;a&#x27;;</span><br><span class="line">        if (!son[p][u]) son[p][u] = ++ idx;</span><br><span class="line">        p = son[p][u];</span><br><span class="line">    &#125;</span><br><span class="line">    cnt[p] ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 查询字符串出现的次数</span><br><span class="line">int query(char *str)</span><br><span class="line">&#123;</span><br><span class="line">    int p = 0;</span><br><span class="line">    for (int i = 0; str[i]; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        int u = str[i] - &#x27;a&#x27;;</span><br><span class="line">        if (!son[p][u]) return 0;</span><br><span class="line">        p = son[p][u];</span><br><span class="line">    &#125;</span><br><span class="line">    return cnt[p];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N = 100010;</span><br><span class="line">int son[N][26],cnt[N],idx;//son[p][u]表示该串下一个字母的位置，cnt负责标记，表示这个树的路径（字符串）的次数</span><br><span class="line">void insert(char* s)</span><br><span class="line">&#123;</span><br><span class="line">    int p=0;</span><br><span class="line">    for(int i=0;s[i];i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int u=s[i]-&#x27;a&#x27;;</span><br><span class="line">        if(!son[p][u]) son[p][u]=++idx;</span><br><span class="line">        //son[p][u]=idx就是把下一个结点的位置存在当前的son[p][u]里,if就是判断是否这个结点有孩子</span><br><span class="line">        //比如之前插入了abc，再插入ab的时候就会判断，如果有就不需要继续插入了，就直接顺延</span><br><span class="line">        p=son[p][u];</span><br><span class="line">    &#125;</span><br><span class="line">    cnt[p]++;</span><br><span class="line">&#125;</span><br><span class="line">int query(char* s)</span><br><span class="line">&#123;</span><br><span class="line">    int p=0;</span><br><span class="line">    for(int i=0;s[i];i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int u=s[i]-&#x27;a&#x27;;</span><br><span class="line">        if(!son[p][u]) return 0;</span><br><span class="line">        p=son[p][u];</span><br><span class="line">    &#125;</span><br><span class="line">    return cnt[p];</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n;</span><br><span class="line">    char op[2];</span><br><span class="line">    char s[N];</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    for(int i=0;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        scanf(&quot;%s%s&quot;,op,s);</span><br><span class="line"></span><br><span class="line">        if(op[0]==&#x27;I&#x27;)</span><br><span class="line">        &#123;</span><br><span class="line">            insert(s);</span><br><span class="line">        &#125;</span><br><span class="line">        if(op[0]==&#x27;Q&#x27;)</span><br><span class="line">        &#123;t</span><br><span class="line">            printf(&quot;%d\n&quot;,query(s));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="并查集："><a href="#并查集：" class="headerlink" title="并查集："></a>并查集：</h4><p><a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/33345/">AcWing 836. 基础_并查集_合并集合java_python_c++ - AcWing</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int find(int x)</span><br><span class="line">    &#123;</span><br><span class="line">        if(p[x]==x) return x;</span><br><span class="line">        return p[x]=find(p[x]);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>合并</strong></p>
<p>把一个集合的根指向另一个集合的根</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void unionset(int x,int y)&#123;</span><br><span class="line"></span><br><span class="line">fa[find(x)]=find(y);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>按秩合并（启发式合并）</strong></p>
<p>实际一般用不到，因为路径压缩已经做的够优秀了</p>
<p>把小集合的根指向大集合的根</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//记录并初始化子树的大小为1</span><br><span class="line">vector&lt;int&gt;siz(N,1);</span><br><span class="line">void unionset(int x,int y)&#123;</span><br><span class="line">	x=find(x),y=find(y);</span><br><span class="line">	if(x==y) return;</span><br><span class="line">	if(siz[x]&gt;siz[y]) swap(x,y);</span><br><span class="line">	fa[x]=y;</span><br><span class="line">	siz[y]+=siz[x];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>p[N] 中 每一个··节点表示当前节点所指向的父节点</p>
<p>快速支持以下操作</p>
<ol>
<li>将两个集合合并</li>
<li>询问两个元素是否在一个集合当中</li>
</ol>
<p>基本原理：每个集合用一棵树来表示。树根的编号就是整个集合的编号。每个结点存储它的父节点，p[x]表示x的父节点</p>
<p>问题1：如何判断树根：<code>if(p[x]==x)</code></p>
<p>问题2：如何求x的集合编号：<code>while(p[x]!=x) x=p[x];</code></p>
<p>问题3：如何合并两个集合：px是x的集合编号，py是y的集合编号，<code>p[x]=y</code></p>
<p>并查集优化：遍历过一次每个结点直接指向根节点 路径压缩</p>
<h4 id="堆："><a href="#堆：" class="headerlink" title="堆："></a>堆：</h4><p>需要的变量：<code>h[N],size</code></p>
<ol>
<li><p>插入一个数</p>
</li>
<li><p>求集合当中的最小值</p>
</li>
<li><p>删除最小值</p>
</li>
<li><p>删除任意一个元素</p>
</li>
<li><p>修改任意一个元素</p>
<p><img src="C:\Users\乌拉拉巴卡巴卡\AppData\Roaming\Typora\typora-user-images\image-20221112173131690.png" alt="image-20221112173131690"></p>
</li>
</ol>
<p>满足完全二叉树</p>
<ol>
<li><p>小根堆：每一个点是小于它左右两边的最小值</p>
</li>
<li><p>存储：一维数组来存</p>
</li>
</ol>
<h4 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h4><h5 id="一般哈希："><a href="#一般哈希：" class="headerlink" title="一般哈希："></a>一般哈希：</h5><p><img src="C:\Users\乌拉拉巴卡巴卡\AppData\Roaming\Typora\typora-user-images\image-20230221224809070.png" alt="image-20230221224809070"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">(1) 拉链法</span><br><span class="line">    int h[N], e[N], ne[N], idx;//h[i]存的链表头结点下标,e[i]存的是链表的值，ne[i]是e[i]结点下一个结点的位置，idx是最新可用的点的下标</span><br><span class="line">//head始终是头结点的下标，</span><br><span class="line"></span><br><span class="line">    // 向哈希表中插入一个数</span><br><span class="line">    void insert(int x)</span><br><span class="line">    &#123;</span><br><span class="line">        int k = (x % N + N) % N;//jiang</span><br><span class="line">        e[idx] = x;</span><br><span class="line">        ne[idx] = h[k];</span><br><span class="line">        h[k] = idx ++ ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 在哈希表中查询某个数是否存在</span><br><span class="line">    bool find(int x)</span><br><span class="line">    &#123;</span><br><span class="line">        int k = (x % N + N) % N;</span><br><span class="line">        for (int i = h[k]; i != -1; i = ne[i])</span><br><span class="line">            if (e[i] == x)</span><br><span class="line">                return true;</span><br><span class="line"></span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">(2) 开放寻址法</span><br><span class="line">    int h[N];</span><br><span class="line"></span><br><span class="line">    // 如果x在哈希表中，返回x的下标；如果x不在哈希表中，返回x应该插入的位置</span><br><span class="line">    int find(int x)</span><br><span class="line">    &#123;</span><br><span class="line">        int t = (x % N + N) % N;</span><br><span class="line">        while (h[t] != null &amp;&amp; h[t] != x)//如果这个坑位有人且不是要找的人，找下个坑位，不会死循环是因为开的空间是数据的两倍</span><br><span class="line">        &#123;</span><br><span class="line">            t ++ ;</span><br><span class="line">            if (t == N) t = 0;</span><br><span class="line">        &#125;</span><br><span class="line">        return t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="字符串哈希"><a href="#字符串哈希" class="headerlink" title="字符串哈希"></a>字符串哈希</h5><p>判断串里是否有一段串跟另一段串一样</p>
<p>进制：131</p>
<p>需要：<code>h[N],x[N]</code></p>
<p>需要BKDR_hash和geth_hash</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef unsigned long long ULL;</span><br><span class="line">const int X = 131;</span><br><span class="line">const int N = 100010;</span><br><span class="line">char s[N];</span><br><span class="line">ULL h[N], x[N];</span><br><span class="line">void BKDR_hash(string s)</span><br><span class="line">&#123;</span><br><span class="line">    h[0] = s[0];</span><br><span class="line">    x[0] = 1;</span><br><span class="line">    for(int i = 1 ; i &lt; s.size() ; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        h[i] = h[i - 1]*X + s[i];</span><br><span class="line">        x[i] = x[i - 1]*X;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ULL get_hash(int left,int right)</span><br><span class="line">&#123;</span><br><span class="line">    return left?h[right]-h[left-1]*x[right-left+1]:h[right];</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n,m;</span><br><span class="line">    int l1,r1,l2,r2;</span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);</span><br><span class="line">    scanf(&quot;%s&quot;,s);</span><br><span class="line">    BKDR_hash(s);</span><br><span class="line">    for(int i=0;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        scanf(&quot;%d%d%d%d&quot;,&amp;l1,&amp;r1,&amp;l2,&amp;r2);</span><br><span class="line">        if(get_hash(l1-1,r1-1)==get_hash(l2-1,r2-1)) printf(&quot;Yes\n&quot;);</span><br><span class="line">        else printf(&quot;No\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/hyman_yx/article/details/54410619">Trie树和字符串哈希都是用于快速检索的数据结构。Trie树典型应用于快速检索（最长前缀匹配），统计，排序和保存大量的字符串，所以经常被搜索引擎系统用于文本词频统计，搜索提示等场景。它的优点是最大限度地减少无谓的字符串比较，查询效率比较高。Trie树的核心思想是空间换时间，利用字符串的公共前缀来降低查询时间的开销以达到提高效率的目的</a><a target="_blank" rel="noopener" href="https://blog.csdn.net/hyman_yx/article/details/54410619">1</a>。</p>
<p><a target="_blank" rel="noopener" href="https://developer.aliyun.com/article/59584">而哈希表则是一种理想情况下不需要任何比较就能一次存取得到所查记录的数据结构。它通过在记录存储位置和关键字之间建立一个确定对应关系f来实现这一点，使每个关键字和一个唯一存储位置相对应。因此，在查找时只需根据这个对应关系f找到给定值K的像f(K)，不需要进行比较便可直接取得所查记录</a><a target="_blank" rel="noopener" href="https://developer.aliyun.com/article/59584">2</a>。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/hyman_yx/article/details/54410619">Trie树典型应用于快速检索（最长前缀匹配），统计，排序和保存大量的字符串，所以经常被搜索引擎系统用于文本词频统计，搜索提示等场景</a><a target="_blank" rel="noopener" href="https://blog.csdn.net/hyman_yx/article/details/54410619">1</a>。哈希表则可以用于快速查找和存储数据。</p>
<p>例如，在一个字典中查找一个单词是否存在，可以使用Trie树来实现。而在一个数据库中查找某个记录，则可以使用哈希表来实现。</p>
<p>总之，在处理大量字符串且需要最长前缀匹配时使用Trie树可能更合适；而在其他情况下使用哈希表可能更合适。</p>
<h4 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h4><p>邻接表存储树和图分析</p>
<p>idx表示边的索引；<br>e[] 表示idx条边的结束节点是什么；<br>ne[] 表示idx条边的同起点的下一条边的idx；<br>h[] 表示节点索引；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">idx = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">&#123;</span><br><span class="line">h[i] = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b;</span><br><span class="line">    ne[idx] = h[a];</span><br><span class="line">    h[a] = idx;</span><br><span class="line">    idx++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意： idx代表的是边的索引，h[a]返回起点为a的节点出去的第一条边的idx；<br>用e[idx]取出终点，当ne[idx] ！&#x3D; -1 时，一直用ne去边，用e取终点节点。</p>
<p>拓扑、dfs、并查集都可以图中判断有没有环， floyd可以找最小环</p>
<p>1.DFS：递归结束条件的选择+状态标记+递归后的恢复<br>2.BFS：模拟队列 q[N], d[N] 使用d数组标记状态<br>3.搜索：解空间的搜索往往需要dfs+剪枝，bfs用来找最短路<br>4.树和图的存储：邻接表 h[N], e[N], ne[N], idx<br>5.树和图的遍历：遍历不用像搜索解空间一样递归后恢复，只用遍历一次即可</p>
<h5 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h5><img src="D:\typora笔记\基础算法.assets\image-20240717104327472.png" alt="image-20240717104327472" style="zoom:50%;" />

<img src="D:\typora笔记\基础算法.assets\image-20240717104924144.png" alt="image-20240717104924144" style="zoom:50%;" />

<h5 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h5><p>记忆：外面集合的点与里面集合的点最短的距离</p>
<p>稠密图 外循环每次选择一条路径，先找到离起始点（这里为1）最近的点，内循环1.for循环找到没选入路径里离起始点最近的点 2.找到后通过这个点对其他点距离更新，把新的点标记表示选上了</p>
<p>用堆优化，散列表。稀疏图</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N = 510;</span><br><span class="line">int n, m;</span><br><span class="line">int g[N][N];//稠密图运用矩阵存储</span><br><span class="line">int dist[N];//dist[i]表示i点到起点的距离</span><br><span class="line">bool st[N];//存已找到最短路径的点</span><br><span class="line">int dijkstra()</span><br><span class="line">&#123;</span><br><span class="line">    memset(dist,0x3f,sizeof(dist));//初始化距离</span><br><span class="line">    dist[1]=0;//***一定记得初始化，起点到起点的距离为0</span><br><span class="line">    for(int i=1;i&lt;n;i++)//每次要选择一条路径，最短路径至少需要n-1条，故1~n-1</span><br><span class="line">    &#123;</span><br><span class="line">        int t=-1;//找到离起始点（这里为1）最近的点</span><br><span class="line">        for(int j=1;j&lt;=n;j++)//把每个点遍历一边找到可以选择的点</span><br><span class="line">        &#123;</span><br><span class="line">           if(!st[j]&amp;&amp;(t==-1||dist[t]&gt;dist[j]))//如果这个点没连上且还没开始选或者此时的点比t点离起点更近，更新</span><br><span class="line">                t=j;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for(int j=1;j&lt;=n;j++)//通过新的点进行节点距离更新</span><br><span class="line">        &#123;</span><br><span class="line">            dist[j]=min(dist[j],dist[t]+g[t][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        st[t]=true;//把新加的点连上</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    if(dist[n]==0x3f3f3f3f) return -1;//如果这个点跟起点的距离仍是0x3f3f3f3f说明到不了n点</span><br><span class="line">    return dist[n];</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int x,y,z;</span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);</span><br><span class="line">    for(int i=1;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for(int j=1;j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(i==j) g[i][j]=0;</span><br><span class="line">            else g[i][j]=0x3f3f3f3f;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=0;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);</span><br><span class="line">        g[x][y]=min(g[x][y],z);//重边把最小的权值换上</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printf(&quot;%d&quot;,dijkstra());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="bellman-ford算法"><a href="#bellman-ford算法" class="headerlink" title="bellman_ford算法"></a>bellman_ford算法</h5><ol>
<li><p>可以限制经过边数</p>
</li>
<li><p>需要</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sturct Edge&#123;</span><br><span class="line"></span><br><span class="line">int a,b,c;//a为边起点，b为边终点，c为边的权</span><br><span class="line"></span><br><span class="line">&#125;edges[M],dist[N],last[N]//需要每次外循环备份dist 记得dist和dist[1]要初始化</span><br></pre></td></tr></table></figure>
</li>
<li><p>内层循环是将每条边进行更新</p>
<p>两层循环 外层经历边数，</p>
<p>内层为auto <code>e=edge[j];</code></p>
<p><code>dist[e.b]=min(dist[e.b],dist[e.a]+e.c);</code></p>
</li>
<li><p>备份原因：防止串联<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_52905520/article/details/126453516">(46条消息) Bellman-ford算法详解_真的没事鸭的博客-CSDN博客</a></p>
</li>
</ol>
<h5 id="spfa（稀疏图）"><a href="#spfa（稀疏图）" class="headerlink" title="spfa（稀疏图）"></a>spfa（稀疏图）</h5><p>用队列（或者数组来进行优化）优化bellman_ford</p>
<p>因为bellman_ford算法如果dist[e.a]都没变小就没必要更新</p>
<p>注意：一定要求题目中不能有负环，所以可以利用这个性质判断是否有负环</p>
<p>需要变量：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int h[N], w[N], e[N], ne[N], idx;//用邻接表来存储</span><br><span class="line">int dist[N];//存距离 记得dist和dist[1]要初始化</span><br><span class="line">bool st[N];//判断是否在队列存在</span><br><span class="line">queue&lt;int&gt; q;//队列里存的是节点号</span><br><span class="line">cnt[N];//可以维护判断是否有负环</span><br></pre></td></tr></table></figure>

<img src="C:\Users\乌拉拉巴卡巴卡\AppData\Roaming\Typora\typora-user-images\image-20221121222707991.png" alt="image-20221121222707991" style="zoom:67%;" />

<p>spfa判断是否有负环通过cnt来记录，如果cnt[j]&gt;&#x3D;n则说明有负环</p>
<p>注意要全部入队，因为1并不一定能到负环。</p>
<p>因为本质上spfa算法是对bellman_ford算法的优化，而<strong>bellman-ford算法遍历k次求出的是从源点经过不超过k条边走到任一点的最短距离</strong>，若两点之间的距离在第n-1次更新后还能更新，不就说明两点之间存在超过n-1条边的最短路了么，那不就是说说存在负环吗。</p>
<h5 id="Floyd"><a href="#Floyd" class="headerlink" title="Floyd"></a>Floyd</h5><p>需要变量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int d[N][N];//注意初始化</span><br><span class="line">d[i][j]=min(d[i][j],d[i][k]+d[k][j]);</span><br></pre></td></tr></table></figure>

<h5 id="Prim"><a href="#Prim" class="headerlink" title="Prim"></a>Prim</h5><p><img src="C:\Users\乌拉拉巴卡巴卡\AppData\Roaming\Typora\typora-user-images\image-20230225214324918.png" alt="image-20230225214324918"></p>
<p>朴素Prim（稠密图）</p>
<p>初始：所有点到集合的距离为正无穷</p>
<p>没选起始点，迭代n次</p>
<p>dist[i] &lt;- 正无穷</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">	t&lt;-找到集合外距离最近的点//第一次可以随便选</span><br><span class="line">	用t更新其他点到集合的距离</span><br><span class="line">	st[t]=true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>堆优化Prim</p>
<h5 id="克鲁斯卡尔算法（稀疏图"><a href="#克鲁斯卡尔算法（稀疏图" class="headerlink" title="克鲁斯卡尔算法（稀疏图)"></a>克鲁斯卡尔算法（稀疏图)</h5><p>需要变量：struct edge 因为只需要保存边的</p>
<p>算法思路： 先把所有边按权值排序，然后根据并查集找到集合没有的点且该边为所有边最小的边后加入集合，统计集合中点的数量，如果边的数量小于n-1说明没有联通，否则就输出最小生成树的权值</p>
<h5 id="染色法"><a href="#染色法" class="headerlink" title="染色法"></a>染色法</h5><p>判断是否是二分图的算法，通过dfs染色</p>
<p>注意无向图add的时候</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">bool dfs(int u, int color) &#123;</span><br><span class="line">    st[u] = color;</span><br><span class="line"></span><br><span class="line">    for(int i = h[u]; i != -1; i = ne[i])&#123;</span><br><span class="line">        int j = e[i];</span><br><span class="line">        if(!st[j]) &#123;</span><br><span class="line">            if(!dfs(j, 3 - color)) return false;</span><br><span class="line">        &#125;else if(st[j] == color) return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主函数注意每个点如果没染色都染色</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">bool flag = true;</span><br><span class="line">   for(int i = 1; i &lt;= n; i ++)&#123;</span><br><span class="line">       if(!st[i])&#123;</span><br><span class="line">           if(!dfs(i, 1))&#123;</span><br><span class="line">               flag = false;</span><br><span class="line">               break;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<h5 id="匈牙利算法"><a href="#匈牙利算法" class="headerlink" title="匈牙利算法"></a>匈牙利算法</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 510, M = 100010;</span><br><span class="line"></span><br><span class="line">int n1, n2, m;</span><br><span class="line">int h[N], e[M], ne[M], idx;</span><br><span class="line">int match[N];  // match[i]：女生i的对象</span><br><span class="line">bool query[N];  // bool st[N];  // 男生是否询问过女生</span><br><span class="line"></span><br><span class="line">void add(int a, int b) &#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int find(int x) &#123;</span><br><span class="line">    for (int i = h[x]; i != -1; i = ne[i]) &#123;  // 遍历男生x的所有可联系女生</span><br><span class="line">        int j = e[i];  // 女生的编号j</span><br><span class="line">        if (!query[j]) &#123;  // 如果没询问过</span><br><span class="line">            query[j] = true;  // 标记为询问，然后去问她</span><br><span class="line">            if (!match[j] || find(match[j]))&#123;  // 如果女生j没有对象，或者女生j的对象match[j]可以再找一个。  // highlight：query的作用就在这里，递归产生的find栈不会再去询问match[j]自己的对象j</span><br><span class="line">                match[j] = x;  // 那女生j把男生x作为对象</span><br><span class="line">                return true;  // 男生x成功找到对象（在未询问女生中）</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return false;  // 男生x没找着对象（在未询问女生中）</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    memset(h, -1, sizeof h);</span><br><span class="line"></span><br><span class="line">    scanf(&quot;%d%d%d&quot;, &amp;n1, &amp;n2, &amp;m);</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; m; i ++ ) &#123;</span><br><span class="line">        int a, b;</span><br><span class="line">        scanf(&quot;%d%d&quot;, &amp;a, &amp;b);</span><br><span class="line">        add(a, b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int res = 0;</span><br><span class="line">    for (int i = 1; i &lt;= n1; i ++ ) &#123;</span><br><span class="line">        memset(query, false, sizeof query);  // 重复使用query，每个男生最初都没有询问过女生</span><br><span class="line">        if (find(i)) res ++ ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printf(&quot;%d\n&quot;, res);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="数学知识"><a href="#数学知识" class="headerlink" title="数学知识"></a>数学知识</h4><p>筛质数 埃式筛法 线性筛法</p>
<p>从小到大枚举每个数</p>
<p>如果当前数没划掉，必定是质数，记录该质数，枚举当前质数的倍数，必定是合数，划掉合数。</p>
<p><img src="C:\Users\乌拉拉巴卡巴卡\AppData\Roaming\Typora\typora-user-images\image-20230106164833221.png" alt="image-20230106164833221"></p>
<p><img src="C:\Users\乌拉拉巴卡巴卡\AppData\Roaming\Typora\typora-user-images\image-20230106181915190.png" alt="image-20230106181915190"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">6.2:埃氏筛(稍加优化版的筛法).</span><br><span class="line">(1).质数定理:1~n中有n/lnn个质数.</span><br><span class="line">(2).原理:在朴素筛法的过程中只用质数项去筛.</span><br><span class="line">(3).时间复杂度:粗略估计:O(n).实际:O(nlog(logn)).</span><br><span class="line">(4).1~n中,只计算质数项的话,”1/2+1/3+1/4+1/5+…+1/n”的大小约为log(logn).</span><br><span class="line">6.3:线性筛</span><br><span class="line">(1).若n在10的6次方的话,线性筛和埃氏筛的时间效率差不多,若n在10的7次方的话,线性筛会比埃氏筛快了大概一倍.</span><br><span class="line">(2).思考:一:线性筛法为什么是线性的?</span><br><span class="line">二:线性筛法的原理是什么?</span><br><span class="line">(3).核心:1~n内的合数p只会被其最小质因子筛掉.</span><br><span class="line">(4).原理:1~n之内的任何一个合数一定会被筛掉,而且筛的时候只用最小质因子来筛,</span><br><span class="line">然后每一个数都只有一个最小质因子,因此每个数都只会被筛一次,因此线性筛法是线性的.</span><br><span class="line">(5).枚举到i的最小质因子的时候就会停下来,即”if(i%primes[j]==0) break;”.</span><br><span class="line">(6).因为从小到大枚举的所有质数,所以当”i%primes[j]!=0”时,primes[j]一定小于i的最小质因子,</span><br><span class="line">primes[j]一定是primes[j]i的最小质因子.</span><br><span class="line">(7).因为是从小到大枚举的所有质数,所以当”i%primes[j]==0”时,primes[j]一定是i的最小质因子,</span><br><span class="line">而primes[j]又是primes[j]的最小质因子,因此primes[j]是iprimes[j]的最小质因子.</span><br><span class="line">(8).关于for循环的解释:</span><br><span class="line">注:首先要把握住一个重点:我们枚举的时候是从小到大枚举的所有质数</span><br><span class="line">1.当i%primes[j]==0时,因为是从小到大枚举的所有质数,所以primes[j]就是i的最小质因子,而primes[j]又是其本身</span><br><span class="line">primes[j]的最小质因子,因此当i%primes[j]==0时,primes[j]是primes[j]i的最小质因子.</span><br><span class="line">2.当i%primes[j]!=0时,因为是从小到大枚举的所有质数,且此时并没有出现过有质数满足i%primes[j]==0,</span><br><span class="line">因此此时的primes[j]一定小于i的最小质因子,而primes[j]又是其本身primes[j]的最小质因子,</span><br><span class="line">所以当i%primes[j]!=0时,primes[j]也是primes[j]*i的最小质因子.</span><br><span class="line">3.综合1,2得知,在内层for循环里面无论何时,primes[j]都是primes[j]i的最小质因子,因此”st[primes[j]*i]=true”</span><br><span class="line">语句就是用primes[j]i这个数的最小质因子来筛掉这个数.</span><br></pre></td></tr></table></figure>


<p>分解质因数 唯一分解定理 试除法</p>
<p><img src="C:\Users\乌拉拉巴卡巴卡\AppData\Roaming\Typora\typora-user-images\image-20230107103929896.png" alt="image-20230107103929896"></p>
<p> <img src="C:\Users\乌拉拉巴卡巴卡\AppData\Roaming\Typora\typora-user-images\image-20230111105948906.png" alt="image-20230111105948906"></p>
<p><ifram src="//player.bilibili.com/player.html?aid=763614192&bvid=BV19r4y127fu&cid=424201509&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" > </iframe></p>
<h4 id="C-STL"><a href="#C-STL" class="headerlink" title="C++ STL"></a>C++ STL</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_39838607/article/details/119653496">(14条消息) c++ map通过值找键与通过键找值得方法(全）_c++中map怎么用值查键_落春只在无意间的博客-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/blog/content/25/">求解斐波那契数列的若干方法 - AcWing</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/yas12345678/article/details/52601454">(61条消息) C++中set用法详解_c++ set_Donny-You的博客-CSDN博客</a></p>
<h4 id="石子合并"><a href="#石子合并" class="headerlink" title="石子合并"></a>石子合并</h4><p>每次合并两个最小的</p>
<p>A B C</p>
<p>A《B《C</p>
<p>A+B+A+B+C《B+C+B+C+A</p>
<p>同时我要知道合并之后此时邻居下一次最小的是谁</p>
<p>问题变成怎么快速找到一个数组里面a[i]+a[i+1]最小的</p>
<p>但注意到先合并和较小的两个的结果一般较优，考虑是否能按先合并小的来求最小值，这种方法是错误的</p>
<p>当其中一个数 与左边合并 和与右边合并消耗相同时，选法不同，结果会不同 ，贪心随机选左边或右边所以不一定正确。</p>
<p>关键点：最后一次合并一定是左边连续的一部分和右边连续的一部分进行合并</p>
<p><strong>递归搜索+保存计划结果&#x3D;记忆化搜索</strong></p>
<p>把递归的计算结果保存下来，那么下次递归到同样的入参时就直接返回先前保存的结果<img src="C:\Users\乌拉拉巴卡巴卡\AppData\Roaming\Typora\typora-user-images\image-20231129210717353.png" alt="image-20231129210717353" style="zoom:67%;" /></p>
<p>石子合并</p>
<p>递归写法（暴力写法）</p>
<p>思路：递归，hash判断是否这个stock被合了无了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> n=<span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> N;</span><br><span class="line"><span class="type">int</span> stocks[n];</span><br><span class="line"><span class="type">int</span> hash[n];</span><br><span class="line"><span class="type">int</span> record[n][<span class="number">2</span>]; </span><br><span class="line"><span class="type">int</span> min=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span>* stocks,<span class="type">int</span> cost,<span class="type">int</span> cnt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(cnt==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//   for(int i=N-1;i&gt;0;i--)</span></span><br><span class="line">        <span class="comment">//   &#123;</span></span><br><span class="line">        <span class="comment">//       printf(&quot;%d %d\n&quot;,record[i][0],record[i][1]);</span></span><br><span class="line">        <span class="comment">//   &#125;</span></span><br><span class="line">        <span class="comment">//   printf(&quot;cost%d &quot;,cost);</span></span><br><span class="line">      <span class="keyword">if</span>(min&gt;cost) &#123;</span><br><span class="line">          min = cost;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//   printf(&quot;\n&quot;);</span></span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N<span class="number">-1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(hash[i]) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> second=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i<span class="number">+1</span>;j&lt;N;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(hash[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    second = j;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">        </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(second==N) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">int</span> tmp = stocks[second];</span><br><span class="line">            hash[i]=<span class="number">0</span>,stocks[second]=stocks[second]+stocks[i];</span><br><span class="line">            record[cnt][<span class="number">0</span>]=i;</span><br><span class="line">            record[cnt][<span class="number">1</span>]=i<span class="number">+1</span>;</span><br><span class="line">            <span class="comment">// printf(&quot;co%d &quot;,cost);</span></span><br><span class="line">             <span class="built_in">dfs</span>(stocks,cost+stocks[second],cnt<span class="number">-1</span>);</span><br><span class="line">            hash[i]=<span class="number">1</span>,stocks[second]=tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;N);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;stocks[i]);</span><br><span class="line">        hash[i]=<span class="number">1</span>;</span><br><span class="line">        record[i][<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">        record[i][<span class="number">1</span>]=<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(stocks,<span class="number">0</span>,N<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,min);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>转化为记忆化搜索</p>
<img src="D:\typora笔记\基础算法.assets\image-20231202205741869.png" alt="image-20231202205741869" style="zoom:50%;" />

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">310</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[N],dp[N][N];</span><br><span class="line"><span class="type">int</span> s[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(dp[l][r]!=<span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> dp[l][r];</span><br><span class="line">    <span class="keyword">if</span>(l==r) &#123;</span><br><span class="line">        dp[l][r]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> min=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=l;i&lt;r;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">        min=min&gt;<span class="built_in">dfs</span>(l,i)+<span class="built_in">dfs</span>(i<span class="number">+1</span>,r)?<span class="built_in">dfs</span>(l,i)+<span class="built_in">dfs</span>(i<span class="number">+1</span>,r):min;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">    dp[l][r]=min+s[r]-s[l<span class="number">-1</span>];</span><br><span class="line">    <span class="comment">// printf(&quot;%d = dp[%d][%d] &quot;,dp[l][r],l,r);</span></span><br><span class="line">     <span class="keyword">return</span> dp[l][r];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">        s[i]=s[i<span class="number">-1</span>]+a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">0x3f3f3f3f</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="built_in">dfs</span>(<span class="number">1</span>,n));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="D:\typora笔记\基础算法.assets\image-20231202215110757.png" alt="image-20231202215110757" style="zoom:50%;" />

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/02/04/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/02/04/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/" itemprop="url">二分查找</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-02-04T15:57:04+08:00">
                2025-02-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="蓝红模板"><a href="#蓝红模板" class="headerlink" title="蓝红模板"></a>蓝红模板</h3><p>因为这个模板是比较常用而且我认为学习是最容易理解且网上也有许多教程和视频所以分享一些对题目理解以及我们所需要的一些注意的东西</p>
<p><strong>首先</strong>什么是<strong>蓝红模板</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int search(int* nums, int numsSize, int target)&#123;</span><br><span class="line">int left=-1,right=numsSize;</span><br><span class="line">while(left+1!=right)</span><br><span class="line">&#123;</span><br><span class="line">    int mid=(left+right)/2;</span><br><span class="line">    if(IsBLUE(m)) l=mid;</span><br><span class="line">    else r=mid;</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">此处添加后处理</span><br><span class="line">*/</span><br><span class="line">return left or right;</span><br><span class="line">&#125;对于IsBLUE和return共同实现了查找的情况</span><br></pre></td></tr></table></figure>

<p>left代表的是蓝色,right代表红色</p>
<p>可以理解为我要在以一个已经拍好的序列找到某个特定的数,二分查找的本质就是划分一条边界,这个边界区分了它在左颜色区域还是在右颜色区域内,所以明白了这一点</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-peak-element/">162. 寻找峰值</a></p>
<p>二分模板一共有两个，分别适用于不同情况。<br>算法思路：假设目标值在闭区间[l, r]中， 每次将区间长度缩小一半，当l &#x3D; r时，我们就找到了目标值。</p>
<p>版本1<br>当我们将区间[l, r]划分成[l, mid]和[mid + 1, r]时，其更新操作是r &#x3D; mid或者l &#x3D; mid + 1;，计算mid时不需要加1。</p>
<p>C++ 代码模板：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int bsearch_1(int l, int r)</span><br><span class="line">&#123;</span><br><span class="line">    while (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        int mid = l + r &gt;&gt; 1;</span><br><span class="line">        if (check(mid)) r = mid;</span><br><span class="line">        else l = mid + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>版本2<br>当我们将区间[l, r]划分成[l, mid - 1]和[mid, r]时，其更新操作是r &#x3D; mid - 1或者l &#x3D; mid;，此时为了防止死循环，计算mid时需要加1。</p>
<p>C++ 代码模板：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int bsearch_2(int l, int r)</span><br><span class="line">&#123;</span><br><span class="line">    while (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        int mid = l + r + 1 &gt;&gt; 1;</span><br><span class="line">        if (check(mid)) l = mid;</span><br><span class="line">        else r = mid - 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>模板1和模板2本质上是根据代码来区分的，而不是应用场景。如果写完之后发现是l &#x3D; mid，那么在计算mid时需要加上1，否则如果写完之后发现是r &#x3D; mid，那么在计算mid时不能加1。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/02/04/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/02/04/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-02-04T15:57:04+08:00">
                2025-02-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>[TOC]</p>
<h1 id="title-动态规划"><a href="#title-动态规划" class="headerlink" title="title: 动态规划"></a>title: 动态规划</h1><h3 id="动态规划方法论以及背包问题"><a href="#动态规划方法论以及背包问题" class="headerlink" title="动态规划方法论以及背包问题"></a>动态规划方法论以及背包问题</h3><p><strong>状态表示</strong>f[i,j]</p>
<p>​		集合 </p>
<p>​				所有选法</p>
<p>​				条件 1. 只从前i个物品中选 2. 总体积&lt;&#x3D;j</p>
<p>​				背包问题：所有只从前i个物品选，并且总体积不超过j的选法</p>
<p>​									只从前i组物品中选，并且总体积不超过j的选法</p>
<p>​		属性 MAX MIN 个数</p>
<p><strong>状态计算</strong> 集合的划分</p>
<p>​				01背包 <code>f[i][j]=Max(f[i-1][j],f[i-1][j-v[i]]+w[i])</code></p>
<p>​							      优化后：<code>f[j]=Max(f[j],f[j-v[i]]+w[i])</code></p>
<p>​				完全背包  优化前：<code>f[i][j]=Max(f[i-1][j],f[i][j-v[i]*k]+w[i]*k)</code></p>
<p>​												注意这里Max里的<code>f[i][j]</code>，因为<code>k</code>从0开始的，所以<code>k=0</code>的时候就是不包含<code>i</code>的集合，然后找到选几个<code>i</code>这个种类的物品价值最大</p>
<p>​								 优化后：<code>f[i][j]=Max(f[i-1][j],f[i][j-v]+w)</code></p>
<p>​				多重背包  优化前：<code>f[i][j]=max(f[i][j],f[i-1][j-v[i]*k]+w[i]*k);</code></p>
<p>​								 二进制优化：多重背包问题通常可转化成01背包问题求解，对物品进行优化，即：一个正整数n，可以被分解成1,2,4,…,2^(k-1)^的形式。其中，k是满足n-2^k^+1&gt;0的最大整数。例如，假设给定价值为2，数量为10的物品，依据二进制优化思想可将10分解为1+2+4+3，则原来价值为2，数量为10的物品可等效转化为价值分别为1<em>2，2</em>2，4<em>2，3</em>2，即价值分别为2，4，8，6，数量均为1的物品。&#x2F;&#x2F;<a target="_blank" rel="noopener" href="https://blog.csdn.net/hnjzsyjyj/article/details/109363826">(43条消息) 多重背包问题（二进制优化）_hnjzsyjyj的博客-CSDN博客_多重背包二进制优化</a></p>
<img src="C:\Users\乌拉拉巴卡巴卡\AppData\Roaming\Typora\typora-user-images\image-20220920150014343.png" alt="image-20220920150014343" style="zoom: 50%;" /> 

<p><strong>注意遍历顺序</strong>： 如果是排序问题所以需将target放在外循环，将nums放在内循环</p>
<p>​							如果是组合问题就target放里面，nums放外面</p>
<p>关于为什么<strong>当问题为组合问题时：先遍历物品，再遍历背包</strong> <strong>当问题为排列问题时：先遍历背包，再遍历物品</strong></p>
<p>我认为 组合是只考虑我是否选了第i个物品，选择第i个物品后状态发生的变化 当考虑过第i种物品后，考虑后面新的物品时候就不会再往前看第i个物品</p>
<p>​			而排列，则是我每次考虑到不同容量的时候，都要考虑每种物品是否能填进去，就会造成为了导致填满而发生顺序上的改变</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/unique-binary-search-trees/">96. 不同的二叉搜索树</a></p>
<p>这个就是组合</p>
<p>令<code>f(0) = 1</code><br><code>f(1) = f(0)*f(0)</code><br><code>f(2) = f(1)*f(0) + f(0)*f(1)</code><br><code>f(3) = f(2)*f(0) + f(1)*f(1) + f(0)*f(2)</code><br>……<br><code>f(n) = f(n-1)*f(0) + f(n-2)*f(1) +……f(0)*f(n-1)</code></p>
<p> <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/length-of-longest-fibonacci-subsequence/">873. 最长的斐波那契子序列的长度</a></p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/get-maximum-in-generated-array/">1646. 获取生成数组中的最大值</a></p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/partition-array-for-maximum-sum/">1043. 分隔数组以得到最大和</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int maxSumAfterPartitioning(int* arr, int arrSize, int k)&#123;</span><br><span class="line">     int dp[501]=&#123;0&#125;;</span><br><span class="line">     for(int i=1;i&lt;arrSize+1;i++)</span><br><span class="line">     &#123;</span><br><span class="line">         int max=arr[i-1];</span><br><span class="line">         dp[i] = dp[i - 1] + arr[i-1];</span><br><span class="line">         for(int j=i-1;j&gt;i-k&amp;&amp;j&gt;0;j--)</span><br><span class="line">         &#123;   </span><br><span class="line">             max=fmax(arr[j-1],max);</span><br><span class="line">             dp[i]=fmax(dp[i],dp[j-1]+(i-j+1)*max);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     return dp[arrSize];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h5><h6 id="139-单词拆分"><a href="#139-单词拆分" class="headerlink" title="139. 单词拆分"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/word-break/">139. 单词拆分</a></h6><p>回溯经典超时</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">bool backtracking(char * s,int sSize,char **wordDict,int wordDictSize)</span><br><span class="line">&#123;</span><br><span class="line">    if(*s==&#x27;\0&#x27;) return true;</span><br><span class="line">    for(int i=0;s[i]!=&#x27;\0&#x27;;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for(int j=0;j&lt;wordDictSize;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(i+1==strlen(wordDict[j]))&#123;</span><br><span class="line">                int k;</span><br><span class="line">                for(k=0;k&lt;=i;k++)</span><br><span class="line">                &#123;</span><br><span class="line">                    if(s[k]!=wordDict[j][k]) break;</span><br><span class="line">                &#125;</span><br><span class="line">               </span><br><span class="line">                if(k==i+1)  </span><br><span class="line">                &#123;</span><br><span class="line">                    if(backtracking(s+i+1,sSize,wordDict,wordDictSize)==true) return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else continue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">bool wordBreak(char * s, char ** wordDict, int wordDictSize)&#123;</span><br><span class="line">int* memo=(int*)malloc(sizeof(int)*(strlen(s)+1));</span><br><span class="line">memset(memo,-1,sizeof(int)*(strlen(s)+1));</span><br><span class="line">    return backtracking(s,strlen(s),wordDict,wordDictSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="322-零钱兑换"><a href="#322-零钱兑换" class="headerlink" title="322. 零钱兑换"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/coin-change/">322. 零钱兑换</a></h6><p><strong>注意</strong>：这里是组合，所以直接target在内，sum在外，然后完全背包问题</p>
<p>状态表示f[i,j]	集合：从i种零前拿出amount值的最少硬币选法</p>
<p>​						  条件：只从前i个选，并且总金额要等于j的选法</p>
<p>​						  属性：<strong>最少的硬币个数</strong></p>
<p>状态计算	集合的划分 <code>f[i][j]=min(f[i][j-coins[i]*k]+k,f[i-1][j])</code></p>
<p>​					完全背包问题的优化后：<code>f[i][j]=min(f[i][j-coins[i]]+1,f[i-1][j])</code></p>
<p>​							    优化成一位数组：<code>f[j]=min[f[j-coins[j]]+1,f[j]]</code> 注意，因为属性为最少的硬币个数，所以要初始化要注意</p>
<p>考虑到集合的性质,当还没选的时候不确定是否能可以用硬币表示，则需要硬币的数量是无穷大的，而<code>f[0]</code>注意单独赋值，因为<code>f[0]</code>为表示<code>account=0</code>的时候需要的最少的硬币个数，其实就是0。</p>
<h6 id="518-零钱兑换-II"><a href="#518-零钱兑换-II" class="headerlink" title="518. 零钱兑换 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/coin-change-2/">518. 零钱兑换 II</a></h6><p><strong>注意</strong>：这里并没有将顺序不同的序列被视作不同的组合。 所以这个是组合问题而不是排列问题，<strong>所以需将target放在外循环，将nums放在内循环</strong>。</p>
<p>状态表示f[i,j]	集合：所有选法：从i种零钱拿出amount值的所有选法</p>
<p>​									 条件：只从前i个物品选，并且总金额要等于j的选法</p>
<p>​									 属性：个数</p>
<p>状态计算	集合的划分</p>
<h6 id="377-组合总和-Ⅳ"><a href="#377-组合总和-Ⅳ" class="headerlink" title="377. 组合总和 Ⅳ"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/combination-sum-iv/">377. 组合总和 Ⅳ</a></h6><p><strong>注意</strong>：这里将顺序不同的序列被视作不同的组合。&#x2F;&#x2F;所以这里跟完全背包有明显的细节差异，完全背包是当你包含第i种数字的时候的情况，这样只会出现就不能将顺序不同的序列算进组合。对任意的<code> f[len][target]</code>而言，组合中的最后一个数字可以选择 nums 中的任意数值，因此<code> f[len][target]</code> 应该为以下所有方案总和</p>
<p>记得初始化 <code>f[0]=1</code></p>
<p>状态表示<code>f[i,j] </code>集合：所有选法：从i种数字拿出target的所有组合选法</p>
<p>​									条件：只从前i个数字选，并且总和要等于j的选法</p>
<p>​									属性：个数</p>
<p>状态计算 集合的划分 <code>f[i][j]+=f[i-1][j]+f[i][j-v[i]]</code> 优化后：<code>f[j]=f[j]+f[j-v[i]]</code></p>
<h5 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70. 爬楼梯"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/climbing-stairs/">70. 爬楼梯</a></h5><p>实际上是完全背包问题，还是靠排列的，所以target在外，num在内</p>
<img src="C:\Users\乌拉拉巴卡巴卡\AppData\Roaming\Typora\typora-user-images\image-20220920183646504.png" alt="image-20220920183646504" style="zoom:67%;" /> 

<p><strong><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/word-break/">139. 单词拆分</a></strong></p>
<p>完全背包问题，单词当作物品，字符串 <code>s</code> 长度当作背包容量，目的是判断物品是否能恰好填满背包。</p>
<p>能否恰好放入背包 </p>
<p>一是取决于背包是否留下足够多的空间放下。</p>
<p>二是前面的空间是填满了的</p>
<h5 id="898-数字三角形-AcWing题库"><a href="#898-数字三角形-AcWing题库" class="headerlink" title="898. 数字三角形 - AcWing题库"></a><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/description/900/">898. 数字三角形 - AcWing题库</a></h5><p> memset(f, -0x3f, sizeof f);</p>
<h5 id=""><a href="#" class="headerlink" title=""></a></h5><h4 id="区间DP"><a href="#区间DP" class="headerlink" title="区间DP"></a>区间DP</h4><h5 id="282-石子合并-AcWing题库"><a href="#282-石子合并-AcWing题库" class="headerlink" title="282. 石子合并 - AcWing题库"></a><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/284/">282. 石子合并 - AcWing题库</a></h5><p><code>f[i][j]</code>表示将第i堆石子到第j堆石子合并成一堆石子的最小代价</p>
<p>状态表示<code>f[i][j]</code> 集合 所有将第i堆石子到第j堆石子合并成一堆石子的合并方式</p>
<p>​								属性 Min</p>
<p>状态表示	根据i~j划分成两堆,以分界线 k&#x3D;j-i+1</p>
<p>1 2 3 4 … k-1  </p>
<p><code>f[i][j]=Min(f[i][j],f[i][k]+f[k+1][j]+s[j]-s[i-1])</code> s这里表示的是前缀和</p>
<h4 id="打家劫舍"><a href="#打家劫舍" class="headerlink" title="打家劫舍"></a>打家劫舍</h4><h5 id="198-打家劫舍"><a href="#198-打家劫舍" class="headerlink" title="198. 打家劫舍"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/house-robber/">198. 打家劫舍</a></h5><p><code>f[i]</code> 集合表示在偷第i号屋子的所有结合</p>
<p>​		   属性 Max</p>
<p>状态表示 集合的划分</p>
<p>没选i号屋子偷窃 选i号屋子偷窃</p>
<p><code>f[i]=Max(f[i-1],f[i-2]+w[i])</code></p>
<h5 id="213-打家劫舍-II"><a href="#213-打家劫舍-II" class="headerlink" title="213. 打家劫舍 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/house-robber-ii/">213. 打家劫舍 II</a></h5><p><code>f[i][j]</code> 集合表示在偷第i号房子的所有集合 </p>
<p>​				属性 Max</p>
<p><code>f[i][j]</code>表示偷了第i号房子且是否偷了第一个的所有集合中的最大值</p>
<p>状态表示 集合的划分</p>
<ol>
<li>选了第一个偷：<ol>
<li>没选i号屋子偷窃；</li>
<li>选i号屋子偷窃</li>
</ol>
</li>
<li>没选第一个偷<ol>
<li>没选i号屋子偷窃；</li>
<li>选i号屋子偷窃</li>
</ol>
</li>
</ol>
<p><code>f[i][0]=Math.max(f[i-1][0],f[i-2][0]+nums[i-1]);</code></p>
<p><code>f[i][1]=Math.max(f[i-1][1],f[i-2][1]+nums[i-1]);</code></p>
<p>最后单独考虑情况。</p>
<h6 id="树形DP"><a href="#树形DP" class="headerlink" title="树形DP"></a>树形DP</h6><h5 id="337-打家劫舍-III"><a href="#337-打家劫舍-III" class="headerlink" title="337. 打家劫舍 III"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/house-robber-iii/">337. 打家劫舍 III</a></h5><p>二叉树要从下往上判断，需要用到后序遍历</p>
<p>（如果是从上往下判断是无法知道这个节点到底是取还是不取的，不知道其孩子的情况）</p>
<p>判断一个节点是否要偷</p>
<p>要看其两个左右子节点和父节点之和是否大于它本身，大于则取左右子孩子，不大于就取它本身，而且还要考虑如果取它本身，</p>
<h4 id="股票问题"><a href="#股票问题" class="headerlink" title="股票问题"></a>股票问题</h4><p>股票问题最简单的方法就是表示状态</p>
<p>买卖股票的状态有：</p>
<ol>
<li>天数</li>
<li>当前是否持有股票</li>
<li>交易次数</li>
</ol>
<p><code>f[i][j][k]</code>表示在第i天，是否持有股票，交易次数有k次的最大利益</p>
<p>状态表示<code>f[i][j][k]</code>集合 所有第i天持有或者不持有股票已经交易了k次的买卖股票方式</p>
<p>​									  属性 Max</p>
<p>状态</p>
<h5 id="121-买卖股票的最佳时机"><a href="#121-买卖股票的最佳时机" class="headerlink" title="121. 买卖股票的最佳时机"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/">121. 买卖股票的最佳时机</a></h5><p>一维dp数组，dp含义是当第i天时的最大利润，遍历顺序为从前到后，前i天的最大收益 &#x3D; max{前i-1天的最大收益，第i天的价格-前i-1天中的最小价格}</p>
<h5 id="122-买卖股票的最佳时机-II"><a href="#122-买卖股票的最佳时机-II" class="headerlink" title="122. 买卖股票的最佳时机 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">122. 买卖股票的最佳时机 II</a></h5><p><img src="C:\Users\乌拉拉巴卡巴卡\AppData\Roaming\Typora\typora-user-images\image-20220930093634130.png" alt="image-20220930093634130"></p>
<p><img src="C:\Users\乌拉拉巴卡巴卡\AppData\Roaming\Typora\typora-user-images\image-20220930093658243.png" alt="image-20220930093658243"></p>
<img src="C:\Users\乌拉拉巴卡巴卡\AppData\Roaming\Typora\typora-user-images\image-20220930094058646.png" alt="image-20220930094058646" style="zoom:50%;" />

<h4 id="子序列问题"><a href="#子序列问题" class="headerlink" title="子序列问题"></a>子序列问题</h4><h5 id="子序列（不连续）"><a href="#子序列（不连续）" class="headerlink" title="子序列（不连续）"></a>子序列（不连续）</h5><h6 id="300-最长递增子序列"><a href="#300-最长递增子序列" class="headerlink" title="300. 最长递增子序列"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-increasing-subsequence/">300. 最长递增子序列</a></h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a&gt;b?a:b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">lengthOfLIS</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span>&#123;</span><br><span class="line"><span class="type">int</span> dp[<span class="number">2500</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> ans=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;numsSize;i++)</span><br><span class="line">&#123;</span><br><span class="line">    dp[i]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;numsSize;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;i;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i]&gt;nums[j])</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i]=max(dp[i],dp[j]+<span class="number">1</span>);</span><br><span class="line">            ans=max(dp[i],ans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>确定状态 状态表示的是以当前为结尾的最长递增子序列。</p>
<p>初始化 </p>
<p>遍历</p>
<h5 id="子序列（连续）"><a href="#子序列（连续）" class="headerlink" title="子序列（连续）"></a>子序列（连续）</h5><h6 id="1143-最长公共子序列"><a href="#1143-最长公共子序列" class="headerlink" title="1143. 最长公共子序列"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-common-subsequence/">1143. 最长公共子序列</a></h6><p>状态表示 <code>f[i,j]</code> 集合 <strong>所有在第一个序列的前i个字母中出现，且在第二个序列的前j个字母中出现的子序列</strong></p>
<p><code>f[i][j]</code>表示在第一个序列的前i个字母中出现并且在第二个序列的前j个字母中出现的最大值</p>
<p>​								属性 Max</p>
<p>状态表示 根据公共序列包含a[i]和b[j]来进行集合划分</p>
<p>​              		<code>f[i,j]</code></p>
<p>00								01						10							11</p>
<p><code>f[i-1][j-1]</code>		<code>f[i-1][j]</code>		<code>f[i][j-1]</code>				<code>f[i-1][j-1]</code>+1</p>
<p><img src="C:\Users\乌拉拉巴卡巴卡\AppData\Roaming\Typora\typora-user-images\image-20230503172714169.png" alt="image-20230503172714169"></p>
<p>​								注意中间这两个的情况，例如<code>f[i-1][j]</code>并不是说明b[i]一定包含在公共子序列中，但<code>f[i-1][j]</code>所表示的一个公共子序列的集合中却表示了b[i]在公共子序列中的情况，也就是<code>f[i-1][j]</code>所表示的所有在第一个序列的前i-1个字母中出现，且在第二个序列的前j个字母中出现的子序列所包含了一种情况就是b[i]存在而a[i]严格不存在的子序列，当然<code>f[i-1][j]</code>也不一定说明a[i]一定有或者b[i]一定有，也包含两者都没有的情况，所有00的情况其实就在<code>f[i-1][j]</code>里面。</p>
<p>10的情况也同理。</p>
<p>11表示都包含，所有在第一个序列的前i个字母中出现，且在第二个序列的前j个字母中出现的子序列比第一个序列的前i-1个字母中出现，且在第二个序列的前j个字母中出现的子序列长度+1。</p>
<p>求最大值不能漏情况，但可以重叠情况，<code>f[i-1][j]</code>和<code>f[i][j-1]</code>有重叠的情况，都重复考虑了a[i]和b[i]至多有一个存在的情况，但不影响结果。</p>
<h5 id="编辑距离"><a href="#编辑距离" class="headerlink" title="编辑距离"></a>编辑距离</h5><h6 id="392-判断子序列"><a href="#392-判断子序列" class="headerlink" title="392. 判断子序列"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/is-subsequence/">392. 判断子序列</a></h6><h6 id="72-编辑距离"><a href="#72-编辑距离" class="headerlink" title="72. 编辑距离"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/edit-distance/">72. 编辑距离</a></h6><h5 id="回文"><a href="#回文" class="headerlink" title="回文"></a>回文</h5><h6 id="647-回文子串"><a href="#647-回文子串" class="headerlink" title="647. 回文子串"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/palindromic-substrings/">647. 回文子串</a></h6><p>状态表示	<code>dp[i][j]</code>表示在i~j区间的子串里是否是回文子串</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">int countSubstrings(char * s)&#123;</span><br><span class="line">    if(s==NULL) return 0;</span><br><span class="line">  </span><br><span class="line">    int l=strlen(s);</span><br><span class="line">      if(l==1) return 1;</span><br><span class="line">    bool dp[l][l];</span><br><span class="line">    memset(dp,0,sizeof(dp));</span><br><span class="line">    int ans=0;</span><br><span class="line">    for(int i=l-1;i&gt;=0;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        for(int j=i;j&lt;l;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(s[i]==s[j])</span><br><span class="line">            &#123;</span><br><span class="line">                if(i==j) </span><br><span class="line">                &#123;dp[i][j]=true;</span><br><span class="line">                continue;&#125;</span><br><span class="line">                if(j-i==1) </span><br><span class="line">                &#123;dp[i][j]=true;</span><br><span class="line">                continue;&#125;</span><br><span class="line">                if(j-i&gt;1) dp[i][j]=dp[i+1][j-1];</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=0;i&lt;l;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for(int j=0;j&lt;l;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;%d &quot;,dp[i][j]);</span><br><span class="line">            if(dp[i][j]==true) ans++;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h6 id="516-最长回文子序列"><a href="#516-最长回文子序列" class="headerlink" title="516. 最长回文子序列"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-palindromic-subsequence/">516. 最长回文子序列</a></h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">int longestPalindromeSubseq(char * s)&#123;</span><br><span class="line">    int l=strlen(s);</span><br><span class="line">    int dp[l+1][l+1];</span><br><span class="line">    memset(dp,0,sizeof(dp));</span><br><span class="line">    for(int i=l;i&gt;=0;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        for(int j=i;j&lt;=l;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(i==0)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][j]=1;continue;</span><br><span class="line">            &#125;</span><br><span class="line">            if(j==i) &#123;</span><br><span class="line">                dp[i][j]=1;continue;</span><br><span class="line">            &#125;</span><br><span class="line">            if(s[i-1]==s[j-1]) dp[i][j]=dp[i+1][j-1]+2;</span><br><span class="line">            else dp[i][j]=fmax(dp[i+1][j],dp[i][j-1]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[1][l];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h6 id="1349-参加考试的最大学生数"><a href="#1349-参加考试的最大学生数" class="headerlink" title="1349. 参加考试的最大学生数"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-students-taking-exam/">1349. 参加考试的最大学生数</a></h6><p> <img src="D:\typora笔记\动态规划.assets\image-20231227214129434.png" alt="image-20231227214129434"></p>
<p>1001快速得到上一排的作为要求1001 1000 001 0000</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) <span class="comment">// 遍历每一行</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">0</span>; l &lt; (<span class="number">1</span> &lt;&lt; n); ++l) <span class="comment">// 遍历上一行的所有状态</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> c = <span class="number">0</span>; c &lt; (<span class="number">1</span> &lt;&lt; n); ++c) <span class="comment">// 遍历当前行的所有状态</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><strong>c这个状态是表示这一排学生坐的状态，把从0到1&lt;&lt;n的都遍历了一遍，首先就通过c&amp;&amp;(1&lt;&lt;j)来判断是否这个j安排人坐，然后再通过这个位置是不是有座位</strong></p>
<p>在最内层循环中，使用一系列条件判断来检查当前座位状态是否合法，即是否可以让学生坐在这个位置。主要的条件包括：</p>
<ul>
<li>座位没有被占用</li>
<li>左上、右上、左侧、右侧、左上、右上、左下、右下都没有其他学生（即相邻位置没有学生）</li>
</ul>
<p><code>if (!(c &amp; (1 &lt;&lt; j))) continue;</code> 这行代码用于检查座位状态 <code>c</code> 中的第 <code>j</code> 位是否为 0。如果为 0，表示在当前座位状态下，第 <code>j</code> 个座位是空的（没有学生坐在上面），那么 <code>continue</code> 将会跳过当前循环，不再执行后续的代码。</p>
<p>这个检查的目的是在处理当前座位状态时，只关注空座位，而忽略已经被占用的座位。如果第 <code>j</code> 位为 1，表示座位被占用，那么 <code>continue</code> 就不会执行，继续执行后续的代码。</p>
<p>在这个程序中，这行代码用于确保当前考虑的座位状态 <code>c</code> 中，只有空座位才会被进一步考虑，而被占用的座位将被跳过。这有助于在动态规划过程中筛选出合法的座位状态。</p>
<p>假设有一个座位状态 <code>c</code>，它是一个二进制数，例如 <code>c = 10101</code>，表示座位状态为有座位（1）和空座位（0）交替排列。</p>
<p>现在，假设我们希望检查第 2 位（从右到左，从 0 开始计数）是否为 0，即检查 <code>c</code> 中的第 2 位是否是空座位。我们可以使用位运算来实现这一检查：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int j = 2; // 第 2 位</span><br><span class="line">if (!(c &amp; (1 &lt;&lt; j))) &#123;</span><br><span class="line">    // 如果第 2 位是 0（空座位），则执行以下代码</span><br><span class="line">    // ...</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    // 如果第 2 位是 1（座位被占用），则执行其他操作或跳过</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>c &amp; (1 &lt;&lt; j)</code> 表示将 <code>1</code> 左移 <code>j</code> 位，然后与 <code>c</code> 进行按位与运算。如果结果为 0，说明第 <code>j</code> 位是空座位，就会进入 <code>if</code> 语句中的代码块。如果结果不为 0，说明第 <code>j</code> 位是被占用的座位，就会执行 <code>else</code> 语句中的代码块。</p>
<p>这样，通过 <code>if (!(c &amp; (1 &lt;&lt; j))) continue;</code> 这行代码，可以确保在处理当前座位状态时，只考虑空座位，而跳过已被占用的座位。</p>
<p><img src="D:\typora笔记\动态规划.assets\image-20231228152158623.png" alt="image-20231228152158623"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">count</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            n = n &amp; (n<span class="number">-1</span>);</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxStudents</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; seats)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = seats.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = seats[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">1</span>&lt;&lt;n));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">0</span>;l&lt;(<span class="number">1</span> &lt;&lt; n); ++l)</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> c = <span class="number">0</span> ; c &lt; (<span class="number">1</span>&lt;&lt;n);++c)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n&amp;&amp;flag;++j) &#123;</span><br><span class="line">                        <span class="keyword">if</span>(!(c&amp;(<span class="number">1</span>&lt;&lt;j))) <span class="keyword">continue</span>;</span><br><span class="line">                        <span class="keyword">if</span>(seats[i][j]==<span class="string">&#x27;#&#x27;</span>) flag = <span class="literal">false</span>;</span><br><span class="line">                        <span class="type">bool</span> lt = j==<span class="number">0</span> ? <span class="literal">false</span> : (c&amp;(<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>)));</span><br><span class="line">                        <span class="type">bool</span> rt = j==n<span class="number">-1</span>? <span class="literal">false</span> : (c&amp;(<span class="number">1</span>&lt;&lt;(j<span class="number">+1</span>)));</span><br><span class="line">                        <span class="type">bool</span> ul = (j==<span class="number">0</span>||i==<span class="number">0</span>)? <span class="literal">false</span>:(l&amp;(<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>)));</span><br><span class="line">                        <span class="type">bool</span> ur = (j==n<span class="number">-1</span>||i==<span class="number">0</span>)? <span class="literal">false</span>:(l&amp;(<span class="number">1</span>&lt;&lt;(j<span class="number">+1</span>)));</span><br><span class="line">                        <span class="keyword">if</span>(lt||rt||ul||ur) flag = <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(flag)</span><br><span class="line">                     dp[i<span class="number">+1</span>][c] = <span class="built_in">max</span>(dp[i<span class="number">+1</span>][c],dp[i][l]+<span class="built_in">count</span>(c));</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="built_in">max_element</span>(<span class="built_in">begin</span>(dp[m]),<span class="built_in">end</span>(dp[m]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/02/04/%E3%80%90Leetcode%E5%88%B7%E9%A2%98%E3%80%912023%E5%B9%B4-2024%E5%B9%B4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/02/04/%E3%80%90Leetcode%E5%88%B7%E9%A2%98%E3%80%912023%E5%B9%B4-2024%E5%B9%B4/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-02-04T15:57:04+08:00">
                2025-02-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>刷题记录</p>
<p>取余法则</p>
<p>（S1+S2）%b &#x3D; （S1%b+S2%b）%b， S1<em>S2%b&#x3D;(S1%B)</em>(S2%b)%b</p>
<h2 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sort-an-array/">912. 排序数组 - 力扣（LeetCode）</a></p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/get-kth-magic-number-lcci/">面试题 17.09. 第 k 个数 - 力扣（LeetCode）</a></p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/">剑指 Offer 21. 调整数组顺序使奇数位于偶数前面 - 力扣（LeetCode）</a></p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sort-colors/">75. 颜色分类 - 力扣（LeetCode）</a></p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/container-with-most-water/comments/">11. 盛最多水的容器 - 力扣（LeetCode）</a></p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/shu-zu-zhong-de-ni-xu-dui-lcof/">https://leetcode.cn/problems/shu-zu-zhong-de-ni-xu-dui-lcof/</a></p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/median-of-two-sorted-arrays/">4. 寻找两个正序数组的中位数 - 力扣（LeetCode）</a></p>
<p>第一种做法：时间复杂度O(m+n)，简单来说就是将两个数组合并成一个数组然后找到中位数相应的位置进行求解。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">    double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;</span><br><span class="line">        float tmp[2010];</span><br><span class="line">        int i=0,j=0,k=0;</span><br><span class="line">        int l=nums1.size()+nums2.size();</span><br><span class="line"></span><br><span class="line">        while(i&lt;nums1.size()&amp;&amp;j&lt;nums2.size())</span><br><span class="line">        &#123;</span><br><span class="line">            if(nums1[i]&lt;nums2[j]) tmp[k++]=nums1[i++];</span><br><span class="line">            else tmp[k++]=nums2[j++];</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        while(i&lt;nums1.size())</span><br><span class="line">        &#123;</span><br><span class="line">            tmp[k++]=nums1[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        while(j&lt;nums2.size()) tmp[k++]=nums2[j++];</span><br><span class="line">     </span><br><span class="line">        if(l%2==0) return (tmp[l/2]+tmp[l/2-1])/2;</span><br><span class="line">        return tmp[l/2]; </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>第二种做法：二分查找</p>
<p>中位数：在只有一个有序数组的时候，中位数把数组分割成两个部分。</p>
<p>根据定义，分数组长度为奇数和偶数讨论</p>
<p>数组长度为奇数时，中位数有1个，不妨把中位数分到左边数组。</p>
<img src="C:\Users\乌拉拉巴卡巴卡\AppData\Roaming\Typora\typora-user-images\image-20230521214542409.png" alt="image-20230521214542409" style="zoom: 50%;" />

<p>在两个有序数组的时候，仍然可以把两个数组分割成两个部分。</p>
<p>我们使用一条分割线把两个数组分别分割成两部分：</p>
<img src="C:\Users\乌拉拉巴卡巴卡\AppData\Roaming\Typora\typora-user-images\image-20230521214718737.png" alt="image-20230521214718737" style="zoom:50%;" />

<p>如果左边有5个元素，右边有4个元素，也就是说当两个数组的元素个数之和为奇数的时候，左边最大的就是中位数。</p>
<p>当两个数组的元素个数之和为偶数的时候，左右两边元素个数相等，由左边最大的和右边最小的求和&#x2F;2得到</p>
<img src="C:\Users\乌拉拉巴卡巴卡\AppData\Roaming\Typora\typora-user-images\image-20230521215114876.png" alt="image-20230521215114876" style="zoom:67%;" />

<img src="C:\Users\乌拉拉巴卡巴卡\AppData\Roaming\Typora\typora-user-images\image-20230521215155647.png" alt="image-20230521215155647" style="zoom:67%;" />

<p>所以我们通过二分查找的方法不断找到符合两个条件的分割线位置</p>
<p>特殊情况：</p>
<img src="C:\Users\乌拉拉巴卡巴卡\AppData\Roaming\Typora\typora-user-images\image-20230521215724388.png" alt="image-20230521215724388" style="zoom:50%;" />

<img src="C:\Users\乌拉拉巴卡巴卡\AppData\Roaming\Typora\typora-user-images\image-20230521215737643.png" alt="image-20230521215737643" style="zoom:50%;" />

<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/search-in-rotated-sorted-array-ii/">https://leetcode.cn/problems/search-in-rotated-sorted-array-ii/</a></p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/search-in-rotated-sorted-array/">https://leetcode.cn/problems/search-in-rotated-sorted-array/</a></p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/guess-number-higher-or-lower/">https://leetcode.cn/problems/guess-number-higher-or-lower/</a></p>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h2 id="前缀和和差分"><a href="#前缀和和差分" class="headerlink" title="前缀和和差分"></a>前缀和和差分</h2><p><img src="C:\Users\乌拉拉巴卡巴卡\AppData\Roaming\Typora\typora-user-images\image-20230523113105976.png" alt="image-20230523113105976"></p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/count-vowel-strings-in-ranges/">2559. 统计范围内的元音字符串数 - 力扣（LeetCode）</a></p>
<p>这题还能预处理和二分查找</p>
<h2 id="贪心-Hash"><a href="#贪心-Hash" class="headerlink" title="贪心+Hash"></a>贪心+Hash</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/largest-values-from-labels/">1090. 受标签影响的最大值 - 力扣（LeetCode）</a></p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-consecutive-sequence/">128. 最长连续序列</a></p>
<h2 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h2><h3 id="一刷"><a href="#一刷" class="headerlink" title="一刷"></a>一刷</h3><p>贪心问题实质就是找到什么情况是局部最优，通过多个局部最优得到全局最优</p>
<ol>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">122. 买卖股票的最佳时机 II</a>【<strong>最终利润是可以分解的，那么本题就很容易了！」</strong></p>
<p>如果分解呢？</p>
<p>假如第0天买入，第3天卖出，那么利润为：prices[3] - prices[0]。</p>
<p>相当于(prices[3] - prices[2]) + (prices[2] - prices[1]) + (prices[1] - prices[0])。</p>
<p><strong>「此时就是把利润分解为每天为单位的维度，而不是从0天到第3天整体去考虑！」</strong></p>
<p>那么根据prices可以得到每天的利润序列：(prices[i] - prices[i - 1])…..(prices[1] - prices[0])。</p>
<p>我们关注了每天的利润，选取正利润是局部最优，以此达到得到最大利润的整体最优</p>
</li>
<li><p>在跳跃游戏I中，⼀个数组看能否跳到终点，其实就是看我们从起点到终点所拓展的最大范围，不要拘泥于只看每步能跳的位置，而是它能跳的位置能够为总的能跳跃的空间范围所作出的贡献，即能否扩大这个范围，使其最后范围大于或等于整个数组长度</p>
</li>
<li><p>跳跃游戏II中题目已经给出一定可以到达终点，那么为了步数最少，<strong>局部最优</strong>是每次跳的时候，在当前的位置可以跳的范围内选择下次能跳最远位置的点跳，这样保证每一步都是最远的，以此达到整体最优。</p>
</li>
<li><p>加油站问题首先是直到经过这个站能加多少油（经过的站的花费与站点加油的差），只要确定最后能剩下油，就说明一定可以绕一圈，只要找到那一个点就可以。然后一层循环，如果累加是负的，说明在这个范围内不可以作为起始点，就以下一个为起点继续</p>
</li>
<li><p>分发糖果和根据身⾼重建队列都是<strong>有两个标准</strong>，做法是先完成一个标准，之后再完成另一个标准，根据圣身高重建队列有个点就是排序的顺序，由大到小有好处是再按照第二个标准插入时候（前面有多少个比数大或者相等），就可以通过插入的状况来判定，因为已经插入的都是比此时的数要大，只要找到现在插入的位置即可，有点像dp数组的思想，通过之前的情况就可以很好的为接下来的操作埋下伏笔。</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/non-overlapping-intervals/">435. 无重叠区间</a>的算法就是排课算法，在教室里上尽可能多的的课就是选择早下课的课程先上，然后再选择不冲突且下课最早的课程上（选课先根据结束课程早晚来排序）。可谓是真正的贪心。而<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/">452. 用最少数量的箭引爆气球</a>就用下面这个来排序，按照end来排正序从小到大，然后想一下牛电灯那个题，想要用少的箭，就要用尽量用区间结尾去引爆气球，这样就可以引爆局部最多，以此到整体最多。</p>
<p>ps：<a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_51627418/article/details/121246105">(37条消息) qsort()中cmp函数_不专业码农的博客-CSDN博客_qsort函数cmp</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* a,<span class="type">const</span> <span class="type">void</span>* b)</span></span><br><span class="line">&#123;   </span><br><span class="line">    <span class="keyword">if</span> ((*(<span class="type">int</span>**)a)[<span class="number">0</span>] == (*(<span class="type">int</span>**)b)[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">return</span> (*(<span class="type">int</span>**)a)[<span class="number">1</span>] &gt; (*(<span class="type">int</span>**)b)[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> (*(<span class="type">int</span>**)a)[<span class="number">1</span>] &gt; (*(<span class="type">int</span>**)b)[<span class="number">1</span>];</span><br><span class="line">&#125; </span><br><span class="line">leetcode申请内存</span><br><span class="line">*returnSize=peopleSize;</span><br><span class="line">*returnColumnSizes=<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*peopleSize);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;peopleSize;i++)</span><br><span class="line">&#123;</span><br><span class="line">    (*returnColumnSizes)[i]=<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">queue</span>[i]=<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-intervals/">56. 合并区间</a>问题就是注意区间的性质，当按照区间起点的大小排序后，区间性质就是如果这两个区间可以合并，说明前区间的终止位置比后区间的起始位置大于或等于。</p>
<p>如果满足这个性质条件，则这个数组就可以向前扩展（注意遍历时候数组看上一个区间），这时候注意一个细节：当前区间的终止位置比后区间的终止位置大的时候要取而代之；</p>
<p>当不满足这个性质条件，则目前遍历到的区间与上一个区间无法合并，上一个区间就可以加入到结果区间里。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return an array of arrays of size *returnSize.</span></span><br><span class="line"><span class="comment"> * The sizes of the arrays are returned as *returnColumnSizes array.</span></span><br><span class="line"><span class="comment"> * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="type">int</span> <span class="title function_">cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* a,<span class="type">const</span> <span class="type">void</span>* b)</span></span><br><span class="line">&#123;   </span><br><span class="line">    <span class="keyword">if</span> ((*(<span class="type">int</span>**)a)[<span class="number">0</span>] == (*(<span class="type">int</span>**)b)[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">return</span> (*(<span class="type">int</span>**)a)[<span class="number">1</span>] &gt; (*(<span class="type">int</span>**)b)[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> (*(<span class="type">int</span>**)a)[<span class="number">0</span>] &gt; (*(<span class="type">int</span>**)b)[<span class="number">0</span>];</span><br><span class="line">&#125; </span><br><span class="line"><span class="type">int</span>** <span class="title function_">merge</span><span class="params">(<span class="type">int</span>** intervals, <span class="type">int</span> intervalsSize, <span class="type">int</span>* intervalsColSize, <span class="type">int</span>* returnSize, <span class="type">int</span>** returnColumnSizes)</span>&#123;</span><br><span class="line">     <span class="type">int</span> **<span class="built_in">queue</span>=(<span class="type">int</span> **)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span> *)*intervalsSize);</span><br><span class="line">    *returnSize=<span class="number">0</span>;</span><br><span class="line">    *returnColumnSizes=<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*intervalsSize);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;intervalsSize;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        (*returnColumnSizes)[i]=<span class="number">2</span>;</span><br><span class="line">        <span class="built_in">queue</span>[i]=<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(intervalsSize==<span class="number">1</span>) &#123;</span><br><span class="line">    *returnSize=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> intervals;</span><br><span class="line">    &#125;</span><br><span class="line">    qsort(intervals,intervalsSize,<span class="keyword">sizeof</span>(<span class="type">int</span>*),cmp);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> n=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;intervalsSize;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(intervals[i][<span class="number">0</span>]&lt;=intervals[i<span class="number">-1</span>][<span class="number">1</span>]) intervals[i][<span class="number">0</span>]=intervals[i<span class="number">-1</span>][<span class="number">0</span>],intervals[i][<span class="number">1</span>]=intervals[i][<span class="number">1</span>]&gt;intervals[i<span class="number">-1</span>][<span class="number">1</span>]?intervals[i][<span class="number">1</span>]:intervals[i<span class="number">-1</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">queue</span>[(*returnSize)][<span class="number">0</span>]=intervals[i<span class="number">-1</span>][<span class="number">0</span>],<span class="built_in">queue</span>[(*returnSize)][<span class="number">1</span>]=intervals[i<span class="number">-1</span>][<span class="number">1</span>],*returnSize+=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(i==intervalsSize<span class="number">-1</span>) <span class="built_in">queue</span>[(*returnSize)][<span class="number">0</span>]=intervals[i][<span class="number">0</span>],<span class="built_in">queue</span>[(*returnSize)][<span class="number">1</span>]=intervals[i][<span class="number">1</span>],*returnSize+=<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,*returnSize);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">queue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/set-intersection-size-at-least-two/">757. 设置交集大小至少为2</a>区间交集问题，面对这一问题首先要排序，按集合起点排序还是按集合终点排序，因为集合散乱没有规律性，选择最少的数是哪些无法从之前所选的情况去判定。而排好序能让我们从规律的集合排序中找出局部最优，即每次选都选一个数尽可能可以满足之后的集合，这样就可以有效减少后面的集合为了满足条件选新的数，那么这个数一定是在后面的集合的区间中存在，而当我们按照起点大小排序，当要选择可以使集合满足条件的数的时候，尽可能选区间末端的数。当然，这题其实最简便的方法就是把条件一一列出，当下个区间有我选的两个数时候，判断情况，然后更新替换上去。</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/lemonade-change/">860. 柠檬水找零</a>这题的贪心体现在找零情况上，找零情况是有限的，每次找零尽量少用5美元，因为5美元是找零最需要的，10美元需要5美元找零，20美元也要5美元来找，所有只有在找20美元少用5美元找零就最好。</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/partition-labels/">763. 划分字母区间</a>想要划分最多，且满足要求，先统计每个出现的字母最后一次出现的位置，再遍历一遍即可得到结果。肯定的是一段字母区间中的所有字母中一定有一个字母为这一段结尾，且这个字母的最后一次出现的位置都比这一段字母区间中的其他字母最后一次出现的位置都要远。通过之前统计每个字母最后一次出现的位置，就可以边遍历，边查找此时这一段中哪个字母的位置最远，当且到达这个最远位置时，就可以划分一段了。</p>
</li>
</ol>
<p>总结：关于区间问题，首先要排序，怎么排序根据区间性质和题目要求，然后列情况，实现效果。</p>
<h3 id="二刷"><a href="#二刷" class="headerlink" title="二刷"></a>二刷</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/wiggle-subsequence/">376. 摆动序列</a></p>
<p><strong>摆动序列</strong> 的 <strong>最长子序列的长度</strong> 取决于子序列峰&#x2F;谷的个数，</p>
<p>峰谷交错，其实就是摆动序列。</p>
<p>从一个局部最优能推到全局最优才是贪心算法的核心。</p>
<p>上坡和下坡中间的都不需要。</p>
<p>判断<code>nums[i]</code>算不算里面的时候其实就是判断前面的差值<code>nums[i]-nums[i-1]</code>和后面的差值<code>nums[i+1]-nums[i]</code>是否是异号的。</p>
<p>这时候会发现前面两个和后面两个很难确定算不算合法长度里。</p>
<p>这时候我们其实可以假定前有一个平地。</p>
<p><img src="C:\Users\乌拉拉巴卡巴卡\AppData\Roaming\Typora\typora-user-images\image-20221009152502346.png" alt="image-20221009152502346"></p>
<p><code>curDiff</code>此时是16 而<code>preDiff</code>此时是0</p>
<p>此时如果要算上1，就不仅仅要满足<code>curDiff&lt;0&amp;&amp;preDiff&gt;0||curDiff&gt;0&amp;&amp;preDiff&lt;0</code></p>
<p>把preDiff此时&#x3D;&#x3D;0算进去。</p>
<p>那要是中间有<code>preDiff=0</code> 那岂不是也会算进去 比如 3 1 1 3</p>
<p>是的，前面的是不是平的并不会影响取 第二个1 第一个1根本没取，因为要求了<code>curDiff</code>不能等于0</p>
<p>最后从0~numSize-1算的是除了最后一个的左边的峰值，加上右边的。</p>
<p>总结：result初始为1（默认最右⾯有⼀个峰值），此时curDiff &gt; 0 &amp;&amp; preDiff &lt;&#x3D; 0，那么 result++（计算了左⾯的峰值），最后得到的result就是2（峰值个数为2即摆动序列⻓度为2）</p>
<h6 id="53-最大子数组和"><a href="#53-最大子数组和" class="headerlink" title="53. 最大子数组和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-subarray/">53. 最大子数组和</a></h6><p>如果连续子数组之和开始变负数，无论后面是什么数，与后面的数加上后相当于“拖累”了后面的数，也就是后面的数如果加上前面连续子数组（负数）会比原来更加小，所以需要从nums[i+1]从新开始算连续子数组之和。此时先判断是否比ans要大，然后再将cur重置为0。（这个顺序很重要）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int maxSubArray(int* nums, int numsSize)&#123;</span><br><span class="line">    int ans=INT_MIN;</span><br><span class="line">    int cur=0;</span><br><span class="line">    for(int i=0;i&lt;numsSize;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cur+=nums[i];</span><br><span class="line">        </span><br><span class="line">        if(ans&lt;cur) ans=cur;</span><br><span class="line">        if(cur&lt;0) cur=0;</span><br><span class="line">    &#125; </span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="贪心-优先队列"><a href="#贪心-优先队列" class="headerlink" title="贪心+优先队列"></a>贪心+优先队列</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/course-schedule-iii/description/?envType=daily-question&envId=2023-09-11">630. 课程表 III - 力扣（LeetCode）</a></p>
<h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/surrounded-regions/">130. 被围绕的区域</a></p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/count-unreachable-pairs-of-nodes-in-an-undirected-graph/">2316. 统计无向图中无法互相到达点对数 - 力扣（LeetCode）</a></p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/satisfiability-of-equality-equations/">990. 等式方程的可满足性 - 力扣（LeetCode）</a></p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-consecutive-sequence/">128. 最长连续序列 - 力扣（LeetCode）</a> </p>
<p>考察并查集的集合数量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int find(int x)</span><br><span class="line"> &#123;</span><br><span class="line">     if(p[x]==x) return x;</span><br><span class="line">     return p[x]=find(p[x]);</span><br><span class="line"> &#125;</span><br><span class="line"> void unionset(int a,int b)</span><br><span class="line"> &#123;</span><br><span class="line">     if(find(a)!=find(b)) sizep[find(b)]+=sizep[find(a)];</span><br><span class="line">     p[find(a)]=find(b);</span><br><span class="line"> &#125;</span><br><span class="line">//注意只有并查集的根节点保存的sizep才是有效的表示了集合大小</span><br></pre></td></tr></table></figure>



<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/accounts-merge/submissions/">721. 账户合并 - 力扣（LeetCode）</a></p>
<p>对于字符串数组vector<string>去重，有以下三种方法（准确的是两种吧）：</p>
<p>（一）先排序、后去重</p>
<p>采用sort函数 （头文件#include <algorithm>）  —— 这时候vector容器元素是从小到大排序好的<br>采用unique函数（头文件#include <algorithm>） —— 将容器中重复的元素放到vector的尾部，返回指向第一个重复元素的迭代器<br>采用vector自带的erase函数（头文件#include <vector>） —— 删除vector中的一段元素<br>具体代码如下↓</p>
<p>void DeleteDuplicated(vector<string> &amp;name)<br>{<br>    sort(name.begin(), name.end());<br>    name.erase(unique(name.begin(), name.end()), name.end());<br>}<br>（二）利用set、unordered_set容器</p>
<p>因为这两个容器的关键字是唯一的<br>因此以元素是否能在unordered_set容器中插入成功作为判断依据<br>如果插入成功 就将该值赋给迭代器指向的下一个值 并将判断迭代器下移一位<br>具体代码如下↓</p>
<p>void remove(vector<string> &amp;str)<br>{<br>    vector<string>::iterator itr &#x3D; str.begin();<br>    unordered_set<string> s;<br>    for (auto curr &#x3D; str.begin(); curr !&#x3D; str.end(); ++curr)<br>    {<br>        if (s.insert(*curr).second)&#x2F;&#x2F;判断是否能插入成功<br>        {<br>            *itr++ &#x3D; *curr;&#x2F;&#x2F;如果成功 就将当前的值赋给到当前迭代器的下一位<br>        }<br>    }<br>    str.erase(itr, str.end());&#x2F;&#x2F;循环完一遍后 当前迭代器的位置就是字段唯一值的末尾<br>}<br>（三）同样利用set、unordered_set容器</p>
<p>如果不是一定要用vector容器来装载字符串 可以考虑直接用set、unordered_set容器来存储！</p>
<p>目前从时间复杂度的角度上来说，第二种方法应该是最快的，其时间复杂度为O(n)。</p>
<p>会继续补充，找到效率最快、最高的方法….<br>————————————————<br>版权声明：本文为CSDN博主「PRPRY」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/lpy369369/article/details/87868580">https://blog.csdn.net/lpy369369/article/details/87868580</a></p>
<h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/magnetic-force-between-two-balls/solution/">1552. 两球之间的磁力 题解 - 力扣（LeetCode）</a></p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-tastiness-of-candy-basket/">2517. 礼盒的最大甜蜜度 - 力扣（LeetCode）</a></p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/count-vowel-strings-in-ranges/">2559. 统计范围内的元音字符串数 - 力扣（LeetCode）</a></p>
<p>这题还能用前缀和</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximize-the-minimum-powered-city/">2528. 最大化城市的最小供电站数目 - 力扣（LeetCode）</a></p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/compare-strings-by-frequency-of-the-smallest-character/submissions/">1170. 比较字符串最小字母出现频次 - 力扣（LeetCode）</a></p>
<h2 id="深搜"><a href="#深搜" class="headerlink" title="深搜"></a>深搜</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/tiling-a-rectangle-with-the-fewest-squares/">1240. 铺瓷砖 - 力扣（LeetCode）</a></p>
<h2 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/modify-graph-edge-weights/">2699. 修改图中的边权 - 力扣（LeetCode）</a></p>
<p>找一条可以从起点到终点的一条路径，然后把其他能修改的边全部封死，之后这个路径如果能修改就把它修改成target，之后再去判断是否有比这个路径更短的，如果没有就是了。</p>
<h2 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/circle-and-rectangle-overlapping/">1401. 圆和矩形是否有重叠</a></p>
<p>题解：<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/24251545">(41 封私信 &#x2F; 80 条消息) 怎样判断平面上一个矩形和一个圆形是否有重叠？ - 知乎 (zhihu.com)</a></p>
<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-subarray-sum-with-one-deletion/solution/jiao-ni-yi-bu-bu-si-kao-dong-tai-gui-hua-hzz6/">教你一步步思考动态规划！（Python&#x2F;Java&#x2F;C++&#x2F;Go） - 删除一次得到子数组最大和 - 力扣（LeetCode）</a></p>
<ol>
<li><p>寻找子问题（从暴力的思路中寻找，枚举子数组的左右端点以及要删除的元素，保留枚举子数组的右端点的想法继续优化，得到原问题变成如果子数组的右端点为i，且最多删除一个数，子数组元素和的最大值是什么？</p>
</li>
<li><p>原问题就可以拆开为两个问题：</p>
<ul>
<li><p>第一个问题：如果子数组右端点为num[i]，且不能删除数字，子数组元素和的最大值是多少？</p>
<ul>
<li>情况一：左边无数字（就是左边不要）子数组为这个数字本身</li>
<li>情况二：左边是连续的子数组，右端点为num[i-1]，且不能删除数字</li>
</ul>
</li>
<li><p>第二个问题：如果子数组右端点为i，且已经删除了数字，子数组元素和的最大值是多少？</p>
<ul>
<li>情况一：如果删除这个右端点，说明子数组为前面的连续子数组，且不能删除数字</li>
<li>情况二：如果删除是前面的数字，也就是变成如果子数组的右端点num[i-1],已经删除了数字，子数组元素和的最大值</li>
</ul>
</li>
</ul>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/02/01/%E3%80%90Leetcode%E5%88%B7%E9%A2%98%E3%80%912025%E5%B9%B4%E5%A4%87%E6%88%98%E6%98%A5%E6%8B%9B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/02/01/%E3%80%90Leetcode%E5%88%B7%E9%A2%98%E3%80%912025%E5%B9%B4%E5%A4%87%E6%88%98%E6%98%A5%E6%8B%9B/" itemprop="url">【Leetcode刷题】2025年备战春招.md</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-02-01T20:41:49+08:00">
                2025-02-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="数据结构目录"><a href="#数据结构目录" class="headerlink" title="数据结构目录"></a>数据结构目录</h1><table>
<thead>
<tr>
<th>数据结构</th>
<th>变种</th>
<th>相关题目</th>
<th>讲解文章</th>
</tr>
</thead>
<tbody><tr>
<td>顺序线性表：向量</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>单链表</td>
<td>1. 双向链表 2. 静态链表 3. 对称矩阵 4. 稀疏矩阵</td>
<td></td>
<td></td>
</tr>
<tr>
<td>哈希表</td>
<td>1. 散列函数 2. 解决碰撞&#x2F;填充因子</td>
<td></td>
<td></td>
</tr>
<tr>
<td>栈和队列</td>
<td>1. 广义栈 2. 双端队列</td>
<td></td>
<td></td>
</tr>
<tr>
<td>队列</td>
<td>1. 链表实现 2. 循环数组实现 3. 双端队列</td>
<td></td>
<td></td>
</tr>
<tr>
<td>字符串</td>
<td>1. KMP算法 2. 有限状态自动机 3. 模式匹配有限状态自动机 4. BM 模式匹配算法 5. BM-KMP 算法 6. BF 算法</td>
<td></td>
<td></td>
</tr>
<tr>
<td>树</td>
<td>1. 二叉树 2. 并查集 3. Huffman 树</td>
<td></td>
<td></td>
</tr>
<tr>
<td>数组实现的堆</td>
<td>1. 极大堆和极小堆 2. 极大极小堆 3. 双端堆 4. d 叉堆</td>
<td></td>
<td></td>
</tr>
<tr>
<td>树实现的堆</td>
<td>1. 左堆 2. 扁堆 3. 二项式堆 4. 斐波那契堆 5. 配对堆</td>
<td></td>
<td></td>
</tr>
<tr>
<td>查找</td>
<td>1. 哈希表 2. 跳跃表 3. 排序二叉树 4. AVL 树 5. B 树 &#x2F; B+ 树 &#x2F; B* 树 6. AA 树 7. 红黑树 8. 排序二叉堆 9. Splay 树 10. 双链树 11. Trie 树 12. R 树</td>
<td></td>
<td></td>
</tr>
<tr>
<td>——————————————–</td>
<td>——————————————————————————————–</td>
<td>—————————</td>
<td>———————————–</td>
</tr>
</tbody></table>
<h1 id="算法目录"><a href="#算法目录" class="headerlink" title="算法目录"></a>算法目录</h1><table>
<thead>
<tr>
<th>算法</th>
<th>具体类型</th>
<th>相关题目</th>
<th>讲解文章</th>
</tr>
</thead>
<tbody><tr>
<td>排序算法</td>
<td>1. 冒泡排序 2. 插入排序 3. 选择排序 4. 希尔 Shell 排序 5. 快速排序 6. 归并排序 7. 堆排序 8. 线性排序算法 9. 自省排序 10. 间接排序 11. 计数排序 12. 基数排序 13. 桶排序 14. 外部排序 - k 路归并败者树 15. 外部排序 - 最佳归并树</td>
<td></td>
<td></td>
</tr>
<tr>
<td>递归与分治</td>
<td></td>
<td>1. 二分搜索&#x2F;查找 2. 大整数的乘法 3. Strassen 矩阵乘法 4. 棋盘覆盖 5. 合并排序 6. 快速排序 7. 线性时间选择 8. 最接近点对问题 9. 循环赛日程表</td>
<td></td>
</tr>
<tr>
<td>动态规划</td>
<td></td>
<td>1. 矩阵连乘问题 2. 最长公共子序列 3. 最大子段和 4. 凸多边形最优三角剖分 5. 多边形游戏 6. 图像压缩 7. 电路布线 8. 流水作业调度 9. 0-1 背包问题&#x2F;背包九讲 10. 最优二叉搜索树 11. 动态规划加速原理 12. 树型 DP</td>
<td></td>
</tr>
<tr>
<td>贪心</td>
<td></td>
<td>1. 活动安排问题 2. 最优装载 3. 哈夫曼编码 4. 单源最短路径 5. 最小生成树 6. 多机调度问题</td>
<td></td>
</tr>
<tr>
<td>回溯法</td>
<td></td>
<td>1. 装载问题 2. 批处理作业调度 3. 符号三角形问题 4. n 后问题 5. 0-1 背包问题 6. 最大团问题 7. 图的 m 着色问题 8. 旅行售货员问题 9. 圆排列问题 10. 电路板排列问题 11. 连续邮资问题</td>
<td></td>
</tr>
<tr>
<td>搜索</td>
<td>1. 枚举 2. DFS 3. BFS 4. 启发式搜索</td>
<td></td>
<td></td>
</tr>
<tr>
<td>随机化</td>
<td>1. 随机数 2. 数值随机化算法 3. Sherwood 舍伍德算法 4. Las Vegas 拉斯维加斯算法 5. Monte Carlo 蒙特卡罗算法</td>
<td>1. 计算 π 值 2. 计算定积分 3. 解非线性方程组 4. 线性时间选择算法 5. 跳跃表 6. n 后问题 7. 整数因子分解 8. 主元素问题 9. 素数测试</td>
<td></td>
</tr>
<tr>
<td>图论</td>
<td>1. 遍历 DFS &#x2F; BFS 2. AOV &#x2F; AOE 网络 3. Kruskal 算法(最小生成树) 4. Prim 算法(最小生成树) 5. Boruvka 算法(最小生成树) 6. Dijkstra 算法(单源最短路径) 7. Bellman-Ford 算法(单源最短路径) 8. SPFA 算法(单源最短路径) 9. Floyd 算法(多源最短路径) 10. Johnson 算法(多源最短路径) 11. Fleury 算法(欧拉回路) 12. Ford-Fulkerson 算法(最大网络流增广路) 13. Edmonds-Karp 算法(最大网络流) 14. Dinic 算法(最大网络流) 15. 一般预流推进算法 16. 最高标号预流推进 HLPP 算法 17. Primal-Dual 原始对偶算法(最小费用流)18. Kosaraju 算法(有向图强连通分量) 19. Tarjan 算法(有向图强连通分量) 20. Gabow 算法(有向图强连通分量) 21. 匈牙利算法(二分图匹配) 22. Hopcroft－Karp 算法(二分图匹配) 23. kuhn munkras 算法(二分图最佳匹配) 24. Edmonds’ Blossom-Contraction 算法(一般图匹配)</td>
<td>1. 图遍历 2. 有向图和无向图的强弱连通性 3. 割点&#x2F;割边 3. AOV 网络和拓扑排序 4. AOE 网络和关键路径 5. 最小代价生成树&#x2F;次小生成树 6. 最短路径问题&#x2F;第 K 短路问题 7. 最大网络流问题 8. 最小费用流问题 9. 图着色问题 10. 差分约束系统 11. 欧拉回路 12. 中国邮递员问题 13. 汉密尔顿回路 14. 最佳边割集&#x2F;最佳点割集&#x2F;最小边割集&#x2F;最小点割集&#x2F;最小路径覆盖&#x2F;最小点集覆盖 15. 边覆盖集 16. 二分图完美匹配和最大匹配问题 17. 仙人掌图 18. 弦图 19. 稳定婚姻问题 20. 最大团问题</td>
<td></td>
</tr>
<tr>
<td>数论</td>
<td></td>
<td>1. 最大公约数 2. 最小公倍数 3. 分解质因数 4. 素数判定 5. 进制转换 6. 高精度计算 7. 整除问题 8. 同余问题 9. 欧拉函数 10. 扩展欧几里得 11. 置换群 12. 母函数 13. 离散变换 14. 康托展开 15. 矩阵 16. 向量 17. 线性方程组 18. 线性规划</td>
<td></td>
</tr>
<tr>
<td>几何</td>
<td></td>
<td>1. 凸包 - Gift wrapping 2. 凸包 - Graham scan 3. 线段问题 4. 多边形和多面体相关问题</td>
<td></td>
</tr>
<tr>
<td>NP 完全</td>
<td>1. 计算模型 2. P 类与 NP 类问题 3. NP 完全问题 4. NP 完全问题的近似算法</td>
<td>1. 随机存取机 RAM 2. 随机存取存储程序机 RASP 3. 图灵机 4. 非确定性图灵机 5. P 类与 NP 类语言 6. 多项式时间验证 7. 多项式时间变换 8. Cook定理 9. 合取范式的可满足性问题 CNF-SAT 10. 3 元合取范式的可满足性问题 3-SAT 11. 团问题 CLIQUE 12. 顶点覆盖问题 VERTEX-COVER 13. 子集和问题 SUBSET-SUM 14. 哈密顿回路问题 HAM-CYCLE 15. 旅行售货员问题 TSP 16. 顶点覆盖问题的近似算法 17. 旅行售货员问题近似算法 18. 具有三角不等式性质的旅行售货员问题 19. 一般的旅行售货员问题 20. 集合覆盖问题的近似算法 21. 子集和问题的近似算法 22. 子集和问题的指数时间算法 23. 子集和问题的多项式时间近似格式</td>
<td></td>
</tr>
<tr>
<td>—-</td>
<td>——————————————————————————–</td>
<td>————————————————————–</td>
<td>—</td>
</tr>
</tbody></table>
<p>要找到数组中的多数元素（出现次数大于 <code>⌊n/2⌋</code> 的元素），可以使用 <strong>Boyer-Moore 投票算法</strong>。该算法的时间复杂度为 <code>O(n)</code>，空间复杂度为 <code>O(1)</code>，非常高效。</p>
<hr>
<h3 id="Boyer-Moore-投票算法"><a href="#Boyer-Moore-投票算法" class="headerlink" title="Boyer-Moore 投票算法"></a><strong>Boyer-Moore 投票算法</strong></h3><p>算法的核心思想是：</p>
<ol>
<li>维护一个候选元素 <code>candidate</code> 和一个计数器 <code>count</code>。</li>
<li>遍历数组：<ul>
<li>如果 <code>count</code> 为 0，则将当前元素设为候选元素 <code>candidate</code>。</li>
<li>如果当前元素等于 <code>candidate</code>，则 <code>count++</code>。</li>
<li>否则，<code>count--</code>。</li>
</ul>
</li>
<li>最终剩下的 <code>candidate</code> 就是多数元素。</li>
</ol>
<p><strong>Boyer-Moore 投票算法</strong> 中的“抵消”是一个关键概念，理解它可以帮助你更好地掌握这个算法的核心思想。下面我会用一个简单的例子来解释“抵消”是如何工作的。</p>
<hr>
<h3 id="抵消的核心思想"><a href="#抵消的核心思想" class="headerlink" title="抵消的核心思想"></a><strong>抵消的核心思想</strong></h3><ol>
<li><p><strong>候选元素</strong>：</p>
<ul>
<li>我们维护一个候选元素 <code>candidate</code>，假设它是多数元素。</li>
<li>同时维护一个计数器 <code>count</code>，表示当前候选元素的“支持度”。</li>
</ul>
</li>
<li><p><strong>抵消规则</strong>：</p>
<ul>
<li>如果当前元素等于 <code>candidate</code>，说明它支持候选元素，<code>count++</code>。</li>
<li>如果当前元素不等于 <code>candidate</code>，说明它反对候选元素，<code>count--</code>。</li>
<li>如果 <code>count</code> 减到 0，说明当前的候选元素可能不是多数元素，需要重新选择候选元素。</li>
</ul>
</li>
<li><p><strong>最终结果</strong>：</p>
<ul>
<li>由于多数元素的数量超过 <code>⌊n/2⌋</code>，即使其他元素与多数元素“抵消”，最终剩下的仍然是多数元素。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a><strong>举例说明</strong></h3><p>假设数组为 <code>[2, 2, 1, 1, 1, 2, 2]</code>，其中 <code>2</code> 是多数元素（出现 4 次，超过 <code>⌊7/2⌋ = 3</code>）。</p>
<h4 id="初始化："><a href="#初始化：" class="headerlink" title="初始化："></a>初始化：</h4><ul>
<li><code>candidate = 2</code>（数组的第一个元素）。</li>
<li><code>count = 1</code>。</li>
</ul>
<h4 id="遍历过程："><a href="#遍历过程：" class="headerlink" title="遍历过程："></a>遍历过程：</h4><ol>
<li><p><strong>第 1 个元素：2</strong></p>
<ul>
<li>当前元素 <code>2</code> 等于 <code>candidate</code>，<code>count++</code>。</li>
<li>状态：<code>candidate = 2</code>，<code>count = 2</code>。</li>
</ul>
</li>
<li><p><strong>第 2 个元素：2</strong></p>
<ul>
<li>当前元素 <code>2</code> 等于 <code>candidate</code>，<code>count++</code>。</li>
<li>状态：<code>candidate = 2</code>，<code>count = 3</code>。</li>
</ul>
</li>
<li><p><strong>第 3 个元素：1</strong></p>
<ul>
<li>当前元素 <code>1</code> 不等于 <code>candidate</code>，<code>count--</code>。</li>
<li>状态：<code>candidate = 2</code>，<code>count = 2</code>。</li>
</ul>
</li>
<li><p><strong>第 4 个元素：1</strong></p>
<ul>
<li>当前元素 <code>1</code> 不等于 <code>candidate</code>，<code>count--</code>。</li>
<li>状态：<code>candidate = 2</code>，<code>count = 1</code>。</li>
</ul>
</li>
<li><p><strong>第 5 个元素：1</strong></p>
<ul>
<li>当前元素 <code>1</code> 不等于 <code>candidate</code>，<code>count--</code>。</li>
<li>状态：<code>candidate = 2</code>，<code>count = 0</code>。</li>
</ul>
</li>
<li><p><strong>第 6 个元素：2</strong></p>
<ul>
<li><code>count</code> 为 0，更新 <code>candidate</code> 为当前元素 <code>2</code>，<code>count = 1</code>。</li>
<li>状态：<code>candidate = 2</code>，<code>count = 1</code>。</li>
</ul>
</li>
<li><p><strong>第 7 个元素：2</strong></p>
<ul>
<li>当前元素 <code>2</code> 等于 <code>candidate</code>，<code>count++</code>。</li>
<li>状态：<code>candidate = 2</code>，<code>count = 2</code>。</li>
</ul>
</li>
</ol>
<h4 id="最终结果："><a href="#最终结果：" class="headerlink" title="最终结果："></a>最终结果：</h4><ul>
<li><code>candidate = 2</code>，即多数元素。</li>
</ul>
<hr>
<h3 id="抵消的直观理解"><a href="#抵消的直观理解" class="headerlink" title="抵消的直观理解"></a><strong>抵消的直观理解</strong></h3><ul>
<li><p><strong>支持与反对</strong>：</p>
<ul>
<li>每次遇到与 <code>candidate</code> 相同的元素，相当于给 <code>candidate</code> 投一票（<code>count++</code>）。</li>
<li>每次遇到与 <code>candidate</code> 不同的元素，相当于反对 <code>candidate</code> 一票（<code>count--</code>）。</li>
</ul>
</li>
<li><p><strong>多数元素的优势</strong>：</p>
<ul>
<li>由于多数元素的数量超过 <code>⌊n/2⌋</code>，即使其他元素联合起来反对，多数元素的“票数”仍然会多于反对票。</li>
<li>例如，在上面的例子中：<ul>
<li><code>2</code> 出现了 4 次，支持票为 4。</li>
<li>其他元素出现了 3 次，反对票为 3。</li>
<li>最终 <code>2</code> 的票数为 <code>4 - 3 = 1</code>，仍然是正数。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="为什么最终剩下的-candidate-是多数元素？"><a href="#为什么最终剩下的-candidate-是多数元素？" class="headerlink" title="为什么最终剩下的 candidate 是多数元素？"></a><strong>为什么最终剩下的 <code>candidate</code> 是多数元素？</strong></h3><ol>
<li><p><strong>假设</strong>：</p>
<ul>
<li>如果 <code>candidate</code> 不是多数元素，那么它的票数会被其他元素“抵消”掉，最终 <code>count</code> 会减到 0。</li>
<li>如果 <code>candidate</code> 是多数元素，即使被部分反对，最终 <code>count</code> 仍然会大于 0。</li>
</ul>
</li>
<li><p><strong>数学保证</strong>：</p>
<ul>
<li>多数元素的数量超过 <code>⌊n/2⌋</code>，因此它的票数一定多于其他元素的总票数。</li>
<li>即使其他元素联合起来反对，多数元素的票数仍然会胜出。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><ul>
<li><strong>抵消</strong> 是 Boyer-Moore 投票算法的核心思想，通过支持与反对的动态平衡，最终找到多数元素。</li>
<li>这个算法的优点是高效（时间复杂度 <code>O(n)</code>，空间复杂度 <code>O(1)</code>），适合处理大规模数据。</li>
<li>如果你理解了“抵消”的概念，就能轻松掌握这个算法的精髓！</li>
</ul>
<ol>
<li><strong>初始化</strong>：<ul>
<li>用一个变量 <code>minPrice</code> 记录当前的最低价格。</li>
<li>用一个变量 <code>maxProfit</code> 记录当前的最大利润。</li>
</ul>
</li>
<li><strong>遍历数组</strong>：<ul>
<li>对于每一天的价格：<ul>
<li>如果当前价格比 <code>minPrice</code> 更低，更新 <code>minPrice</code>。</li>
<li>否则，计算当前价格与 <code>minPrice</code> 的差值，如果这个差值大于 <code>maxProfit</code>，更新 <code>maxProfit</code>。</li>
</ul>
</li>
</ul>
</li>
<li><strong>返回结果</strong>：<ul>
<li>最终 <code>maxProfit</code> 就是最大利润。</li>
</ul>
</li>
</ol>
<h1 id="贪心问题跳跃游戏"><a href="#贪心问题跳跃游戏" class="headerlink" title="贪心问题跳跃游戏"></a>贪心问题跳跃游戏</h1><p>通过贪心算法来解决。我们可以维护一个变量 <code>max_reach</code>，表示当前能够到达的最远位置。遍历数组时，更新 <code>max_reach</code>，并检查是否能够到达或超过最后一个下标。</p>
<h3 id="具体步骤："><a href="#具体步骤：" class="headerlink" title="具体步骤："></a>具体步骤：</h3><ol>
<li>初始化 <code>max_reach</code> 为 0，表示当前能够到达的最远位置。</li>
<li>遍历数组 <code>nums</code>，对于每个位置 <code>i</code>：<ul>
<li>如果 <code>i &gt; max_reach</code>，说明无法到达当前位置，直接返回 <code>false</code>。</li>
<li>更新 <code>max_reach</code> 为 <code>max(max_reach, i + nums[i])</code>，表示从当前位置能够跳跃到的最远位置。</li>
<li>如果 <code>max_reach</code> 已经大于或等于最后一个下标，返回 <code>true</code>。</li>
</ul>
</li>
<li>如果遍历结束后还没有返回 <code>true</code>，则返回 <code>false</code>。</li>
</ol>
<h1 id="贪心问题跳跃游戏-1"><a href="#贪心问题跳跃游戏-1" class="headerlink" title="贪心问题跳跃游戏"></a>贪心问题跳跃游戏</h1><h3 id="关键思想"><a href="#关键思想" class="headerlink" title="关键思想"></a><strong>关键思想</strong></h3><ul>
<li>**<code>current_end</code>**：表示当前跳跃能到达的最远位置。</li>
<li>**<code>max_far</code>**：表示从当前位置到<code>current_end</code>之间，所有位置能跳到的最远位置。</li>
<li>**<code>jumps</code>**：记录跳跃的次数。</li>
</ul>
<p>当我们遍历数组时，每次到达<code>current_end</code>时，意味着我们已经用尽了当前跳跃的范围，必须进行一次新的跳跃，才能继续前进。</p>
<h3 id="为什么遍历到current-end表示需要进行一次跳跃？"><a href="#为什么遍历到current-end表示需要进行一次跳跃？" class="headerlink" title="为什么遍历到current_end表示需要进行一次跳跃？"></a><strong>为什么遍历到<code>current_end</code>表示需要进行一次跳跃？</strong></h3><ol>
<li><strong>跳跃的范围</strong>：<ul>
<li>假设我们从位置<code>i</code>开始跳跃，跳跃的范围是<code>[i, i + nums[i]]</code>。</li>
<li>在这个范围内，我们可以选择跳到任意一个位置。</li>
</ul>
</li>
<li><strong>贪心策略</strong>：<ul>
<li>为了最小化跳跃次数，我们希望每次跳跃都尽可能跳得更远。</li>
<li>因此，在当前位置到<code>current_end</code>之间，我们会不断更新<code>max_far</code>，记录从这些位置能跳到的最远位置。</li>
</ul>
</li>
<li><strong>到达<code>current_end</code>时的意义</strong>：<ul>
<li>当我们遍历到<code>current_end</code>时，意味着我们已经用尽了当前跳跃的范围。</li>
<li>此时，我们必须进行一次新的跳跃，才能继续前进。</li>
<li>新的跳跃范围是从<code>current_end</code>到<code>max_far</code>。</li>
</ul>
</li>
</ol>
<h3 id="换个理解"><a href="#换个理解" class="headerlink" title="换个理解"></a>换个理解</h3><ol>
<li><strong><code>current_end</code>是当前跳跃的边界</strong>：<ul>
<li>在遍历数组时，<code>current_end</code>表示当前跳跃能到达的最远位置。</li>
<li>在<code>current_end</code>之前的所有位置，都可以通过当前跳跃到达。</li>
</ul>
</li>
<li><strong><code>max_far</code>是下一步跳跃的最远范围</strong>：<ul>
<li>在遍历到<code>current_end</code>之前，我们会不断更新<code>max_far</code>，记录从当前位置到<code>current_end</code>之间所有位置能跳到的最远位置。</li>
<li>这个<code>max_far</code>就是下一步跳跃的边界。</li>
</ul>
</li>
<li><strong>到达<code>current_end</code>时表示需要一次新的跳跃</strong>：<ul>
<li>当遍历到<code>current_end</code>时，表示我们已经用尽了当前跳跃的范围。</li>
<li>此时，必须进行一次新的跳跃（<code>jumps++</code>），才能继续前进。</li>
<li>新的跳跃范围是从<code>current_end</code>到<code>max_far</code>。</li>
</ul>
</li>
<li>**更新<code>current_end</code>为<code>max_far</code>**：<ul>
<li>每次跳跃后，<code>current_end</code>更新为<code>max_far</code>，表示新的跳跃边界。</li>
<li>这样，我们就可以继续遍历数组，直到到达最后一个位置。</li>
</ul>
</li>
</ol>
<h1 id="除自身以外元素的乘积"><a href="#除自身以外元素的乘积" class="headerlink" title="除自身以外元素的乘积"></a>除自身以外元素的乘积</h1><ol>
<li><strong>初始化结果数组</strong>：<ul>
<li>使用 <code>make</code> 创建一个长度为 <code>n</code> 的切片 <code>answer</code>，用于存储结果。</li>
</ul>
</li>
<li><strong>计算前缀积</strong>：<ul>
<li>从左到右遍历数组，计算每个位置左边所有元素的乘积，并存储在 <code>answer</code> 中。</li>
<li><code>prefix</code> 变量用于累乘左边的元素。</li>
</ul>
</li>
<li><strong>计算后缀积并更新结果</strong>：<ul>
<li>从右到左遍历数组，计算每个位置右边所有元素的乘积，并将其与 <code>answer</code> 中的值相乘。</li>
<li><code>suffix</code> 变量用于累乘右边的元素。</li>
</ul>
</li>
<li><strong>返回结果</strong>：<ul>
<li>最终返回 <code>answer</code> 切片。</li>
</ul>
</li>
</ol>
<ul>
<li><strong>前缀积</strong>：对于数组中的每个元素 <code>nums[i]</code>，前缀积是它左边所有元素的乘积。<br>例如，数组 <code>[a, b, c, d]</code> 中，<code>c</code> 的前缀积是 <code>a * b</code>。</li>
<li><strong>后缀积</strong>：对于 <code>nums[i]</code>，后缀积是它右边所有元素的乘积。<br>例如，<code>b</code> 的后缀积是 <code>c * d</code>。</li>
</ul>
<p>最终结果 <code>answer[i] = 前缀积[i] * 后缀积[i]</code>。这种方法避免了除法，同时满足时间复杂度 <code>O(n)</code> 和空间复杂度 <code>O(1)</code>（输出数组不计入空间）。</p>
<h1 id="贪心问题加油站"><a href="#贪心问题加油站" class="headerlink" title="贪心问题加油站"></a>贪心问题加油站</h1><ol>
<li><strong>总油量检查</strong>：<ul>
<li>计算 <code>gas[i] - cost[i]</code> 的总和 <code>totalTank</code>。</li>
<li>如果 <code>totalTank &lt; 0</code>，说明总油量不足以绕环路行驶一周，直接返回 <code>-1</code>。</li>
</ul>
</li>
<li><strong>贪心选择起点</strong>：<ul>
<li>遍历每个加油站，计算净油量 <code>margin = gas[i] - cost[i]</code>。</li>
<li>维护当前油箱的剩余油量 <code>currentTank</code>。</li>
<li>如果 <code>currentTank &lt; 0</code>，说明从当前起点无法继续前进，将起点设为下一个加油站，并重置 <code>currentTank</code>。</li>
</ul>
</li>
<li><strong>返回结果</strong>：<ul>
<li>如果遍历结束后 <code>totalTank &gt;= 0</code>，说明存在解，返回起点 <code>start</code>。</li>
<li>否则返回 <code>-1</code>。</li>
</ul>
</li>
</ol>
<h1 id="数论"><a href="#数论" class="headerlink" title="数论"></a>数论</h1><h2 id="LCR-072-x-的平方根：牛顿迭代法"><a href="#LCR-072-x-的平方根：牛顿迭代法" class="headerlink" title="LCR 072. x 的平方根：牛顿迭代法"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/jJ0w9p/">LCR 072. x 的平方根</a>：牛顿迭代法</h2><p>泰勒展开第二项进行运算</p>
<p><img src="C:\Users\Jinju\blog\source\images\image-20250206133342150.png" alt="image-20250206133342150"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">  toleration := 0.001</span><br><span class="line">x0 := float64(1.0)</span><br><span class="line">for &#123;</span><br><span class="line"></span><br><span class="line">	x1 :=float64(x0 - (x0*x0-float64(x))/(2*x0)) </span><br><span class="line">	</span><br><span class="line">	if diff := x1 - x0; diff &lt; toleration &amp;&amp; -diff &lt; toleration &#123;</span><br><span class="line">		break</span><br><span class="line">		&#125;</span><br><span class="line">		x0 = x1</span><br><span class="line">	&#125;</span><br><span class="line">       result:=int(x0)</span><br><span class="line">	if result*result &gt; x &#123;</span><br><span class="line">	    return result - 1</span><br><span class="line">    &#125;</span><br><span class="line">	return result</span><br></pre></td></tr></table></figure>

<p>参考链接：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1px4y127PD/?spm_id_from=333.1391.0.0&vd_source=9a75a4b5f792c3cd3b921c00fec104bb">https://www.bilibili.com/video/BV1px4y127PD/?spm_id_from=333.1391.0.0&amp;vd_source=9a75a4b5f792c3cd3b921c00fec104bb</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/01/03/2025.01.03%20%E5%AE%9E%E7%8E%B0%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E5%92%8CGitHub%E7%9A%84%E8%87%AA%E5%8A%A8%E5%8C%96%E5%90%8C%E6%AD%A5%EF%BC%88%E5%8D%9A%E5%AE%A2%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/01/03/2025.01.03%20%E5%AE%9E%E7%8E%B0%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E5%92%8CGitHub%E7%9A%84%E8%87%AA%E5%8A%A8%E5%8C%96%E5%90%8C%E6%AD%A5%EF%BC%88%E5%8D%9A%E5%AE%A2%EF%BC%89/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-01-03T16:32:46+08:00">
                2025-01-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="自动同步Github的Blog"><a href="#自动同步Github的Blog" class="headerlink" title="自动同步Github的Blog"></a>自动同步Github的Blog</h1><ol>
<li><p>配置好你需要的脚本</p>
</li>
<li><p>创建一个批处理文件运行这个脚本</p>
</li>
<li><p>创建一个批处理文件运行上面的批处理文件防止cmd闪退，然后start+批处理文件路径</p>
</li>
<li><p>右键我的电脑-管理-系统计划程序-创建基本任务可以随意命名，选择想要启动的时间来启动脚本，找到步骤三创建的批处理文件打开，点击完成即可</p>
</li>
</ol>
<p>ref: <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Gg411R7dD/?spm_id_from=333.337.search-card.all.click&vd_source=9a75a4b5f792c3cd3b921c00fec104bb">https://www.bilibili.com/video/BV1Gg411R7dD/?spm_id_from=333.337.search-card.all.click&amp;vd_source=9a75a4b5f792c3cd3b921c00fec104bb</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/">&lt;i class&#x3D;&quot;fa fa-angle-left&quot;&gt;&lt;&#x2F;i&gt;</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/4/">&lt;i class&#x3D;&quot;fa fa-angle-right&quot;&gt;&lt;&#x2F;i&gt;</a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="" />
          <p class="site-author-name" itemprop="name"></p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">33</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" target="_blank" rel="noopener" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" target="_blank" rel="noopener" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Gemini
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.2"></script>



  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  





  

  

  

  

  

  

</body>
</html>
