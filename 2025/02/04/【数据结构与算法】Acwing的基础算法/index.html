<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta name="description" content="title:Acwing的基础算法 快速排序12345678910111213void quick_sort(int q[], int l, int r)&#123;    if (l &gt;&#x3D; r) return;    int i &#x3D; l - 1, j &#x3D; r + 1, x &#x3D; q[l + r &gt;&gt; 1];    while (i &lt; j)    &#123;">
<meta property="og:type" content="article">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/2025/02/04/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E3%80%91Acwing%E7%9A%84%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="title:Acwing的基础算法 快速排序12345678910111213void quick_sort(int q[], int l, int r)&#123;    if (l &gt;&#x3D; r) return;    int i &#x3D; l - 1, j &#x3D; r + 1, x &#x3D; q[l + r &gt;&gt; 1];    while (i &lt; j)    &#123;">
<meta property="og:locale">
<meta property="og:image" content="d:\typora%E7%AC%94%E8%AE%B0\%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95.assets\image-20231227203029359.png">
<meta property="og:image" content="c:\Users\%E4%B9%8C%E6%8B%89%E6%8B%89%E5%B7%B4%E5%8D%A1%E5%B7%B4%E5%8D%A1\AppData\Roaming\Typora\typora-user-images\image-20230603224710262.png">
<meta property="og:image" content="c:\Users\%E4%B9%8C%E6%8B%89%E6%8B%89%E5%B7%B4%E5%8D%A1%E5%B7%B4%E5%8D%A1\AppData\Roaming\Typora\typora-user-images\image-20230603224827020.png">
<meta property="og:image" content="c:\Users\%E4%B9%8C%E6%8B%89%E6%8B%89%E5%B7%B4%E5%8D%A1%E5%B7%B4%E5%8D%A1\AppData\Roaming\Typora\typora-user-images\image-20221112173131690.png">
<meta property="og:image" content="c:\Users\%E4%B9%8C%E6%8B%89%E6%8B%89%E5%B7%B4%E5%8D%A1%E5%B7%B4%E5%8D%A1\AppData\Roaming\Typora\typora-user-images\image-20230221224809070.png">
<meta property="og:image" content="d:\typora%E7%AC%94%E8%AE%B0\%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95.assets\image-20240717104327472.png">
<meta property="og:image" content="d:\typora%E7%AC%94%E8%AE%B0\%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95.assets\image-20240717104924144.png">
<meta property="og:image" content="c:\Users\%E4%B9%8C%E6%8B%89%E6%8B%89%E5%B7%B4%E5%8D%A1%E5%B7%B4%E5%8D%A1\AppData\Roaming\Typora\typora-user-images\image-20221121222707991.png">
<meta property="og:image" content="c:\Users\%E4%B9%8C%E6%8B%89%E6%8B%89%E5%B7%B4%E5%8D%A1%E5%B7%B4%E5%8D%A1\AppData\Roaming\Typora\typora-user-images\image-20230225214324918.png">
<meta property="og:image" content="c:\Users\%E4%B9%8C%E6%8B%89%E6%8B%89%E5%B7%B4%E5%8D%A1%E5%B7%B4%E5%8D%A1\AppData\Roaming\Typora\typora-user-images\image-20230106164833221.png">
<meta property="og:image" content="c:\Users\%E4%B9%8C%E6%8B%89%E6%8B%89%E5%B7%B4%E5%8D%A1%E5%B7%B4%E5%8D%A1\AppData\Roaming\Typora\typora-user-images\image-20230106181915190.png">
<meta property="og:image" content="c:\Users\%E4%B9%8C%E6%8B%89%E6%8B%89%E5%B7%B4%E5%8D%A1%E5%B7%B4%E5%8D%A1\AppData\Roaming\Typora\typora-user-images\image-20230107103929896.png">
<meta property="og:image" content="c:\Users\%E4%B9%8C%E6%8B%89%E6%8B%89%E5%B7%B4%E5%8D%A1%E5%B7%B4%E5%8D%A1\AppData\Roaming\Typora\typora-user-images\image-20230111105948906.png">
<meta property="og:image" content="c:\Users\%E4%B9%8C%E6%8B%89%E6%8B%89%E5%B7%B4%E5%8D%A1%E5%B7%B4%E5%8D%A1\AppData\Roaming\Typora\typora-user-images\image-20231129210717353.png">
<meta property="og:image" content="d:\typora%E7%AC%94%E8%AE%B0\%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95.assets\image-20231202205741869.png">
<meta property="og:image" content="d:\typora%E7%AC%94%E8%AE%B0\%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95.assets\image-20231202215110757.png">
<meta property="article:published_time" content="2025-02-04T07:57:04.725Z">
<meta property="article:modified_time" content="2025-02-07T08:06:03.504Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="d:\typora%E7%AC%94%E8%AE%B0\%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95.assets\image-20231227203029359.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Gemini',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://example.com/2025/02/04/【数据结构与算法】Acwing的基础算法/"/>





  <title> | Hexo</title>
  














<meta name="generator" content="Hexo 7.3.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/02/04/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E3%80%91Acwing%E7%9A%84%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline"></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-02-04T15:57:04+08:00">
                2025-02-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <hr>
<h2 id="title-Acwing的基础算法"><a href="#title-Acwing的基础算法" class="headerlink" title="title:Acwing的基础算法"></a>title:Acwing的基础算法</h2><p><img src="D:\typora笔记\基础算法.assets\image-20231227203029359.png" alt="image-20231227203029359"></p>
<h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = l - <span class="number">1</span>, j = r + <span class="number">1</span>, x = q[l + r &gt;&gt; <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">do</span> i ++ ; <span class="keyword">while</span> (q[i] &lt; x);</span><br><span class="line">        <span class="keyword">do</span> j -- ; <span class="keyword">while</span> (q[j] &gt; x);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) <span class="built_in">swap</span>(q[i], q[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">quick_sort</span>(q, l, j), <span class="built_in">quick_sort</span>(q, j + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意一下边界问题</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/SHU15121856/article/details/109839618">(48条消息) 【算法学习笔记】8：快速排序中的边界问题_LauZyHou的博客-CSDN博客_快速排序边界问题</a></p>
<h4 id="高精度乘法"><a href="#高精度乘法" class="headerlink" title="高精度乘法"></a>高精度乘法</h4><p>t&#x3D;0;</p>
<p>循环到A.size()||t</p>
<p>本位 C<del>n</del>&#x3D;（A[n]*B+t<del>n-1</del>）%10</p>
<p>给下一位进位 t<del>n+1</del>&#x3D;（A[n]*B）&#x2F;10</p>
<h4 id="前缀和与差分"><a href="#前缀和与差分" class="headerlink" title="前缀和与差分"></a>前缀和与差分</h4><p>前缀和是输出原序列中从第 l个数到第 r个数的和（求出某个区间的和）</p>
<p>差分是将序列中某个区间 <code>[l,r] </code>之间的每个数加上一个数。</p>
<p>​	差分关键：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void insert(int l,int r,int c)&#123;</span><br><span class="line">    a[l]+=c;</span><br><span class="line">    a[r+1]-=c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先把每个数字放进去，使得数组a的每个前缀和仍为0</p>
<p>后在插入区间内求出前缀和就完成在区间加上一个数</p>
<h4 id="二进制算法"><a href="#二进制算法" class="headerlink" title="二进制算法"></a>二进制算法</h4><ol>
<li><p>第n位是1还是0 x&gt;&gt;n&amp;1</p>
</li>
<li><p>取得末端第一个是1以及后面的位</p>
<p>例子：比如 5 101 得到的是1 8 1000 得到的是1000</p>
<p>lowbit就是x&amp;-x -x为~x+1（-x为x取反然后+1）</p>
<p>可以通过lowbit知道数字二进制形式有多少个1</p>
</li>
</ol>
<h4 id="单链表："><a href="#单链表：" class="headerlink" title="单链表："></a>单链表：</h4><p>一般用邻接表 存储树和图</p>
<h4 id="双链表："><a href="#双链表：" class="headerlink" title="双链表："></a>双链表：</h4><p>优化某些问题 e[N]表示某个值 ne[N]表示某个点的next指针 通过下标关联起来 空结点ne用-1表示</p>
<h4 id="栈："><a href="#栈：" class="headerlink" title="栈："></a>栈：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// tt表示栈顶</span><br><span class="line">int stk[N], tt = 0;</span><br><span class="line"></span><br><span class="line">// 向栈顶插入一个数</span><br><span class="line">stk[ ++ tt] = x;</span><br><span class="line"></span><br><span class="line">// 从栈顶弹出一个数</span><br><span class="line">tt -- ;</span><br><span class="line"></span><br><span class="line">// 栈顶的值</span><br><span class="line">stk[tt];</span><br><span class="line"></span><br><span class="line">// 判断栈是否为空</span><br><span class="line">if (tt &gt; 0)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="普通队列："><a href="#普通队列：" class="headerlink" title="普通队列："></a>普通队列：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// hh 表示队头，tt表示队尾</span><br><span class="line">int q[N], hh = 0, tt = -1;</span><br><span class="line"></span><br><span class="line">// 向队尾插入一个数</span><br><span class="line">q[ ++ tt] = x;</span><br><span class="line"></span><br><span class="line">// 从队头弹出一个数</span><br><span class="line">hh ++ ;</span><br><span class="line"></span><br><span class="line">// 队头的值</span><br><span class="line">q[hh];</span><br><span class="line"></span><br><span class="line">// 判断队列是否为空</span><br><span class="line">if (hh &lt;= tt)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="循环队列："><a href="#循环队列：" class="headerlink" title="循环队列："></a>循环队列：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// hh 表示队头，tt表示队尾的后一个位置</span><br><span class="line">int q[N], hh = 0, tt = 0;</span><br><span class="line"></span><br><span class="line">// 向队尾插入一个数</span><br><span class="line">q[tt ++ ] = x;</span><br><span class="line">if (tt == N) tt = 0;</span><br><span class="line"></span><br><span class="line">// 从队头弹出一个数</span><br><span class="line">hh ++ ;</span><br><span class="line">if (hh == N) hh = 0;</span><br><span class="line"></span><br><span class="line">// 队头的值</span><br><span class="line">q[hh];</span><br><span class="line"></span><br><span class="line">// 判断队列是否为空</span><br><span class="line">if (hh != tt)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="单调栈："><a href="#单调栈：" class="headerlink" title="单调栈："></a>单调栈：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">常见模型：找出每个数左边离它最近的比它大/小的数</span><br><span class="line">int tt = 0;</span><br><span class="line">for (int i = 1; i &lt;= n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    while (tt &amp;&amp; check(stk[tt], i)) tt -- ;</span><br><span class="line">    stk[ ++ tt] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="单调队列："><a href="#单调队列：" class="headerlink" title="单调队列："></a>单调队列：</h4><ol>
<li>用普通队列该怎么做</li>
<li>将队列中的没有用的元素删掉-&gt;具有了单调性</li>
<li>可以用O(1)时间从队头&#x2F;队尾取出最值</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (i - k + 1 &gt; q[hh]) ++ hh;                  // 若队首出窗口，hh加1</span><br><span class="line">while (hh &lt;= tt &amp;&amp; a[i] &lt;= a[q[tt]]) -- tt;    // 若队尾不单调，tt减1，保证了队头为最小</span><br><span class="line">q[++ tt] = i;                                  // 下标加到队尾，这个元素在后面左窗口缩小的时候可能会成为窗口最凶安置</span><br><span class="line">if (i + 1 &gt;= k) printf(&quot;%d &quot;, a[q[hh]]);       // 输出结果</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\乌拉拉巴卡巴卡\AppData\Roaming\Typora\typora-user-images\image-20230603224710262.png" alt="image-20230603224710262"></p>
<p><img src="C:\Users\乌拉拉巴卡巴卡\AppData\Roaming\Typora\typora-user-images\image-20230603224827020.png" alt="image-20230603224827020"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">常见模型：找出滑动窗口中的最大值/最小值</span><br><span class="line">int hh = 0, tt = -1;</span><br><span class="line">for (int i = 0; i &lt; n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    while (hh &lt;= tt &amp;&amp; check_out(q[hh])) hh ++ ;  // 判断队头是否滑出窗口</span><br><span class="line">    while (hh &lt;= tt &amp;&amp; check(q[tt], i)) tt -- ;</span><br><span class="line">    q[ ++ tt] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h4><p>i和j比较，同则next[i]&#x3D;++j</p>
<p>不同则j看前一个next跳转到新的位置再进行i和j比较</p>
<p>字符串的next数组：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">for(int i=1,j=0;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        while(j&amp;&amp;a[i]!=a[j])</span><br><span class="line">        &#123;</span><br><span class="line">            j=next[j-1];</span><br><span class="line">        &#125;</span><br><span class="line">        if(a[i]==a[j])</span><br><span class="line">        &#123;</span><br><span class="line">            next[i]=j+1;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        if(j==0) next[i]=0,j++;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>对比模式串：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">for(int i=0,j=0;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">          while(j&amp;&amp;a[j]!=b[i]) j=next[j-1];</span><br><span class="line">          if(b[i]==a[j]) </span><br><span class="line">          &#123;</span><br><span class="line">              j++;</span><br><span class="line">          &#125;</span><br><span class="line">          if(j==n)</span><br><span class="line">          &#123;</span><br><span class="line">              j=next[j-1];</span><br><span class="line">              printf(&quot;%d &quot;,i-n+1);</span><br><span class="line">          &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h4 id="Tire树"><a href="#Tire树" class="headerlink" title="Tire树"></a>Tire树</h4><p>需要变量：<code>int son[N][26],cnt[N],id</code></p>
<p>高效地存储和查找字符串</p>
<p>集合的数据结构</p>
<p>每一个出现的结点都会有唯一一个编号idx（也即rxc说的指针）<br>不是按层数来编的，是按出现的先后顺序编的</p>
<p>idx是先把idx自增1再赋值给<code>son[p][u]</code>，而idx是先自增1再赋值给<code>son[p][u]</code>，二者的区别在于，习惯于根节点的编号为0，而存储每一个单词下标是从1开始的，idx++相当于第一个值赋值给了根节点，理解一下这里</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">int son[N][26], cnt[N], idx;</span><br><span class="line">// 0号点既是根节点，又是空节点</span><br><span class="line">// son[][]存储树中每个节点的子节点</span><br><span class="line">// cnt[]存储以每个节点结尾的单词数量</span><br><span class="line"></span><br><span class="line">// 插入一个字符串</span><br><span class="line">void insert(char *str)</span><br><span class="line">&#123;</span><br><span class="line">    int p = 0;</span><br><span class="line">    for (int i = 0; str[i]; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        int u = str[i] - &#x27;a&#x27;;</span><br><span class="line">        if (!son[p][u]) son[p][u] = ++ idx;</span><br><span class="line">        p = son[p][u];</span><br><span class="line">    &#125;</span><br><span class="line">    cnt[p] ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 查询字符串出现的次数</span><br><span class="line">int query(char *str)</span><br><span class="line">&#123;</span><br><span class="line">    int p = 0;</span><br><span class="line">    for (int i = 0; str[i]; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        int u = str[i] - &#x27;a&#x27;;</span><br><span class="line">        if (!son[p][u]) return 0;</span><br><span class="line">        p = son[p][u];</span><br><span class="line">    &#125;</span><br><span class="line">    return cnt[p];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N = 100010;</span><br><span class="line">int son[N][26],cnt[N],idx;//son[p][u]表示该串下一个字母的位置，cnt负责标记，表示这个树的路径（字符串）的次数</span><br><span class="line">void insert(char* s)</span><br><span class="line">&#123;</span><br><span class="line">    int p=0;</span><br><span class="line">    for(int i=0;s[i];i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int u=s[i]-&#x27;a&#x27;;</span><br><span class="line">        if(!son[p][u]) son[p][u]=++idx;</span><br><span class="line">        //son[p][u]=idx就是把下一个结点的位置存在当前的son[p][u]里,if就是判断是否这个结点有孩子</span><br><span class="line">        //比如之前插入了abc，再插入ab的时候就会判断，如果有就不需要继续插入了，就直接顺延</span><br><span class="line">        p=son[p][u];</span><br><span class="line">    &#125;</span><br><span class="line">    cnt[p]++;</span><br><span class="line">&#125;</span><br><span class="line">int query(char* s)</span><br><span class="line">&#123;</span><br><span class="line">    int p=0;</span><br><span class="line">    for(int i=0;s[i];i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int u=s[i]-&#x27;a&#x27;;</span><br><span class="line">        if(!son[p][u]) return 0;</span><br><span class="line">        p=son[p][u];</span><br><span class="line">    &#125;</span><br><span class="line">    return cnt[p];</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n;</span><br><span class="line">    char op[2];</span><br><span class="line">    char s[N];</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    for(int i=0;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        scanf(&quot;%s%s&quot;,op,s);</span><br><span class="line"></span><br><span class="line">        if(op[0]==&#x27;I&#x27;)</span><br><span class="line">        &#123;</span><br><span class="line">            insert(s);</span><br><span class="line">        &#125;</span><br><span class="line">        if(op[0]==&#x27;Q&#x27;)</span><br><span class="line">        &#123;t</span><br><span class="line">            printf(&quot;%d\n&quot;,query(s));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="并查集："><a href="#并查集：" class="headerlink" title="并查集："></a>并查集：</h4><p><a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/33345/">AcWing 836. 基础_并查集_合并集合java_python_c++ - AcWing</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int find(int x)</span><br><span class="line">    &#123;</span><br><span class="line">        if(p[x]==x) return x;</span><br><span class="line">        return p[x]=find(p[x]);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>合并</strong></p>
<p>把一个集合的根指向另一个集合的根</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void unionset(int x,int y)&#123;</span><br><span class="line"></span><br><span class="line">fa[find(x)]=find(y);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>按秩合并（启发式合并）</strong></p>
<p>实际一般用不到，因为路径压缩已经做的够优秀了</p>
<p>把小集合的根指向大集合的根</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//记录并初始化子树的大小为1</span><br><span class="line">vector&lt;int&gt;siz(N,1);</span><br><span class="line">void unionset(int x,int y)&#123;</span><br><span class="line">	x=find(x),y=find(y);</span><br><span class="line">	if(x==y) return;</span><br><span class="line">	if(siz[x]&gt;siz[y]) swap(x,y);</span><br><span class="line">	fa[x]=y;</span><br><span class="line">	siz[y]+=siz[x];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>p[N] 中 每一个··节点表示当前节点所指向的父节点</p>
<p>快速支持以下操作</p>
<ol>
<li>将两个集合合并</li>
<li>询问两个元素是否在一个集合当中</li>
</ol>
<p>基本原理：每个集合用一棵树来表示。树根的编号就是整个集合的编号。每个结点存储它的父节点，p[x]表示x的父节点</p>
<p>问题1：如何判断树根：<code>if(p[x]==x)</code></p>
<p>问题2：如何求x的集合编号：<code>while(p[x]!=x) x=p[x];</code></p>
<p>问题3：如何合并两个集合：px是x的集合编号，py是y的集合编号，<code>p[x]=y</code></p>
<p>并查集优化：遍历过一次每个结点直接指向根节点 路径压缩</p>
<h4 id="堆："><a href="#堆：" class="headerlink" title="堆："></a>堆：</h4><p>需要的变量：<code>h[N],size</code></p>
<ol>
<li><p>插入一个数</p>
</li>
<li><p>求集合当中的最小值</p>
</li>
<li><p>删除最小值</p>
</li>
<li><p>删除任意一个元素</p>
</li>
<li><p>修改任意一个元素</p>
<p><img src="C:\Users\乌拉拉巴卡巴卡\AppData\Roaming\Typora\typora-user-images\image-20221112173131690.png" alt="image-20221112173131690"></p>
</li>
</ol>
<p>满足完全二叉树</p>
<ol>
<li><p>小根堆：每一个点是小于它左右两边的最小值</p>
</li>
<li><p>存储：一维数组来存</p>
</li>
</ol>
<h4 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h4><h5 id="一般哈希："><a href="#一般哈希：" class="headerlink" title="一般哈希："></a>一般哈希：</h5><p><img src="C:\Users\乌拉拉巴卡巴卡\AppData\Roaming\Typora\typora-user-images\image-20230221224809070.png" alt="image-20230221224809070"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">(1) 拉链法</span><br><span class="line">    int h[N], e[N], ne[N], idx;//h[i]存的链表头结点下标,e[i]存的是链表的值，ne[i]是e[i]结点下一个结点的位置，idx是最新可用的点的下标</span><br><span class="line">//head始终是头结点的下标，</span><br><span class="line"></span><br><span class="line">    // 向哈希表中插入一个数</span><br><span class="line">    void insert(int x)</span><br><span class="line">    &#123;</span><br><span class="line">        int k = (x % N + N) % N;//jiang</span><br><span class="line">        e[idx] = x;</span><br><span class="line">        ne[idx] = h[k];</span><br><span class="line">        h[k] = idx ++ ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 在哈希表中查询某个数是否存在</span><br><span class="line">    bool find(int x)</span><br><span class="line">    &#123;</span><br><span class="line">        int k = (x % N + N) % N;</span><br><span class="line">        for (int i = h[k]; i != -1; i = ne[i])</span><br><span class="line">            if (e[i] == x)</span><br><span class="line">                return true;</span><br><span class="line"></span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">(2) 开放寻址法</span><br><span class="line">    int h[N];</span><br><span class="line"></span><br><span class="line">    // 如果x在哈希表中，返回x的下标；如果x不在哈希表中，返回x应该插入的位置</span><br><span class="line">    int find(int x)</span><br><span class="line">    &#123;</span><br><span class="line">        int t = (x % N + N) % N;</span><br><span class="line">        while (h[t] != null &amp;&amp; h[t] != x)//如果这个坑位有人且不是要找的人，找下个坑位，不会死循环是因为开的空间是数据的两倍</span><br><span class="line">        &#123;</span><br><span class="line">            t ++ ;</span><br><span class="line">            if (t == N) t = 0;</span><br><span class="line">        &#125;</span><br><span class="line">        return t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="字符串哈希"><a href="#字符串哈希" class="headerlink" title="字符串哈希"></a>字符串哈希</h5><p>判断串里是否有一段串跟另一段串一样</p>
<p>进制：131</p>
<p>需要：<code>h[N],x[N]</code></p>
<p>需要BKDR_hash和geth_hash</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef unsigned long long ULL;</span><br><span class="line">const int X = 131;</span><br><span class="line">const int N = 100010;</span><br><span class="line">char s[N];</span><br><span class="line">ULL h[N], x[N];</span><br><span class="line">void BKDR_hash(string s)</span><br><span class="line">&#123;</span><br><span class="line">    h[0] = s[0];</span><br><span class="line">    x[0] = 1;</span><br><span class="line">    for(int i = 1 ; i &lt; s.size() ; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        h[i] = h[i - 1]*X + s[i];</span><br><span class="line">        x[i] = x[i - 1]*X;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ULL get_hash(int left,int right)</span><br><span class="line">&#123;</span><br><span class="line">    return left?h[right]-h[left-1]*x[right-left+1]:h[right];</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n,m;</span><br><span class="line">    int l1,r1,l2,r2;</span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);</span><br><span class="line">    scanf(&quot;%s&quot;,s);</span><br><span class="line">    BKDR_hash(s);</span><br><span class="line">    for(int i=0;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        scanf(&quot;%d%d%d%d&quot;,&amp;l1,&amp;r1,&amp;l2,&amp;r2);</span><br><span class="line">        if(get_hash(l1-1,r1-1)==get_hash(l2-1,r2-1)) printf(&quot;Yes\n&quot;);</span><br><span class="line">        else printf(&quot;No\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/hyman_yx/article/details/54410619">Trie树和字符串哈希都是用于快速检索的数据结构。Trie树典型应用于快速检索（最长前缀匹配），统计，排序和保存大量的字符串，所以经常被搜索引擎系统用于文本词频统计，搜索提示等场景。它的优点是最大限度地减少无谓的字符串比较，查询效率比较高。Trie树的核心思想是空间换时间，利用字符串的公共前缀来降低查询时间的开销以达到提高效率的目的</a><a target="_blank" rel="noopener" href="https://blog.csdn.net/hyman_yx/article/details/54410619">1</a>。</p>
<p><a target="_blank" rel="noopener" href="https://developer.aliyun.com/article/59584">而哈希表则是一种理想情况下不需要任何比较就能一次存取得到所查记录的数据结构。它通过在记录存储位置和关键字之间建立一个确定对应关系f来实现这一点，使每个关键字和一个唯一存储位置相对应。因此，在查找时只需根据这个对应关系f找到给定值K的像f(K)，不需要进行比较便可直接取得所查记录</a><a target="_blank" rel="noopener" href="https://developer.aliyun.com/article/59584">2</a>。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/hyman_yx/article/details/54410619">Trie树典型应用于快速检索（最长前缀匹配），统计，排序和保存大量的字符串，所以经常被搜索引擎系统用于文本词频统计，搜索提示等场景</a><a target="_blank" rel="noopener" href="https://blog.csdn.net/hyman_yx/article/details/54410619">1</a>。哈希表则可以用于快速查找和存储数据。</p>
<p>例如，在一个字典中查找一个单词是否存在，可以使用Trie树来实现。而在一个数据库中查找某个记录，则可以使用哈希表来实现。</p>
<p>总之，在处理大量字符串且需要最长前缀匹配时使用Trie树可能更合适；而在其他情况下使用哈希表可能更合适。</p>
<h4 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h4><p>邻接表存储树和图分析</p>
<p>idx表示边的索引；<br>e[] 表示idx条边的结束节点是什么；<br>ne[] 表示idx条边的同起点的下一条边的idx；<br>h[] 表示节点索引；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">idx = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">&#123;</span><br><span class="line">h[i] = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b;</span><br><span class="line">    ne[idx] = h[a];</span><br><span class="line">    h[a] = idx;</span><br><span class="line">    idx++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意： idx代表的是边的索引，h[a]返回起点为a的节点出去的第一条边的idx；<br>用e[idx]取出终点，当ne[idx] ！&#x3D; -1 时，一直用ne去边，用e取终点节点。</p>
<p>拓扑、dfs、并查集都可以图中判断有没有环， floyd可以找最小环</p>
<p>1.DFS：递归结束条件的选择+状态标记+递归后的恢复<br>2.BFS：模拟队列 q[N], d[N] 使用d数组标记状态<br>3.搜索：解空间的搜索往往需要dfs+剪枝，bfs用来找最短路<br>4.树和图的存储：邻接表 h[N], e[N], ne[N], idx<br>5.树和图的遍历：遍历不用像搜索解空间一样递归后恢复，只用遍历一次即可</p>
<h5 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h5><img src="D:\typora笔记\基础算法.assets\image-20240717104327472.png" alt="image-20240717104327472" style="zoom:50%;" />

<img src="D:\typora笔记\基础算法.assets\image-20240717104924144.png" alt="image-20240717104924144" style="zoom:50%;" />

<h5 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h5><p>记忆：外面集合的点与里面集合的点最短的距离</p>
<p>稠密图 外循环每次选择一条路径，先找到离起始点（这里为1）最近的点，内循环1.for循环找到没选入路径里离起始点最近的点 2.找到后通过这个点对其他点距离更新，把新的点标记表示选上了</p>
<p>用堆优化，散列表。稀疏图</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N = 510;</span><br><span class="line">int n, m;</span><br><span class="line">int g[N][N];//稠密图运用矩阵存储</span><br><span class="line">int dist[N];//dist[i]表示i点到起点的距离</span><br><span class="line">bool st[N];//存已找到最短路径的点</span><br><span class="line">int dijkstra()</span><br><span class="line">&#123;</span><br><span class="line">    memset(dist,0x3f,sizeof(dist));//初始化距离</span><br><span class="line">    dist[1]=0;//***一定记得初始化，起点到起点的距离为0</span><br><span class="line">    for(int i=1;i&lt;n;i++)//每次要选择一条路径，最短路径至少需要n-1条，故1~n-1</span><br><span class="line">    &#123;</span><br><span class="line">        int t=-1;//找到离起始点（这里为1）最近的点</span><br><span class="line">        for(int j=1;j&lt;=n;j++)//把每个点遍历一边找到可以选择的点</span><br><span class="line">        &#123;</span><br><span class="line">           if(!st[j]&amp;&amp;(t==-1||dist[t]&gt;dist[j]))//如果这个点没连上且还没开始选或者此时的点比t点离起点更近，更新</span><br><span class="line">                t=j;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for(int j=1;j&lt;=n;j++)//通过新的点进行节点距离更新</span><br><span class="line">        &#123;</span><br><span class="line">            dist[j]=min(dist[j],dist[t]+g[t][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        st[t]=true;//把新加的点连上</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    if(dist[n]==0x3f3f3f3f) return -1;//如果这个点跟起点的距离仍是0x3f3f3f3f说明到不了n点</span><br><span class="line">    return dist[n];</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int x,y,z;</span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);</span><br><span class="line">    for(int i=1;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for(int j=1;j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(i==j) g[i][j]=0;</span><br><span class="line">            else g[i][j]=0x3f3f3f3f;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=0;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);</span><br><span class="line">        g[x][y]=min(g[x][y],z);//重边把最小的权值换上</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printf(&quot;%d&quot;,dijkstra());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="bellman-ford算法"><a href="#bellman-ford算法" class="headerlink" title="bellman_ford算法"></a>bellman_ford算法</h5><ol>
<li><p>可以限制经过边数</p>
</li>
<li><p>需要</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sturct Edge&#123;</span><br><span class="line"></span><br><span class="line">int a,b,c;//a为边起点，b为边终点，c为边的权</span><br><span class="line"></span><br><span class="line">&#125;edges[M],dist[N],last[N]//需要每次外循环备份dist 记得dist和dist[1]要初始化</span><br></pre></td></tr></table></figure>
</li>
<li><p>内层循环是将每条边进行更新</p>
<p>两层循环 外层经历边数，</p>
<p>内层为auto <code>e=edge[j];</code></p>
<p><code>dist[e.b]=min(dist[e.b],dist[e.a]+e.c);</code></p>
</li>
<li><p>备份原因：防止串联<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_52905520/article/details/126453516">(46条消息) Bellman-ford算法详解_真的没事鸭的博客-CSDN博客</a></p>
</li>
</ol>
<h5 id="spfa（稀疏图）"><a href="#spfa（稀疏图）" class="headerlink" title="spfa（稀疏图）"></a>spfa（稀疏图）</h5><p>用队列（或者数组来进行优化）优化bellman_ford</p>
<p>因为bellman_ford算法如果dist[e.a]都没变小就没必要更新</p>
<p>注意：一定要求题目中不能有负环，所以可以利用这个性质判断是否有负环</p>
<p>需要变量：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int h[N], w[N], e[N], ne[N], idx;//用邻接表来存储</span><br><span class="line">int dist[N];//存距离 记得dist和dist[1]要初始化</span><br><span class="line">bool st[N];//判断是否在队列存在</span><br><span class="line">queue&lt;int&gt; q;//队列里存的是节点号</span><br><span class="line">cnt[N];//可以维护判断是否有负环</span><br></pre></td></tr></table></figure>

<img src="C:\Users\乌拉拉巴卡巴卡\AppData\Roaming\Typora\typora-user-images\image-20221121222707991.png" alt="image-20221121222707991" style="zoom:67%;" />

<p>spfa判断是否有负环通过cnt来记录，如果cnt[j]&gt;&#x3D;n则说明有负环</p>
<p>注意要全部入队，因为1并不一定能到负环。</p>
<p>因为本质上spfa算法是对bellman_ford算法的优化，而<strong>bellman-ford算法遍历k次求出的是从源点经过不超过k条边走到任一点的最短距离</strong>，若两点之间的距离在第n-1次更新后还能更新，不就说明两点之间存在超过n-1条边的最短路了么，那不就是说说存在负环吗。</p>
<h5 id="Floyd"><a href="#Floyd" class="headerlink" title="Floyd"></a>Floyd</h5><p>需要变量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int d[N][N];//注意初始化</span><br><span class="line">d[i][j]=min(d[i][j],d[i][k]+d[k][j]);</span><br></pre></td></tr></table></figure>

<h5 id="Prim"><a href="#Prim" class="headerlink" title="Prim"></a>Prim</h5><p><img src="C:\Users\乌拉拉巴卡巴卡\AppData\Roaming\Typora\typora-user-images\image-20230225214324918.png" alt="image-20230225214324918"></p>
<p>朴素Prim（稠密图）</p>
<p>初始：所有点到集合的距离为正无穷</p>
<p>没选起始点，迭代n次</p>
<p>dist[i] &lt;- 正无穷</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">	t&lt;-找到集合外距离最近的点//第一次可以随便选</span><br><span class="line">	用t更新其他点到集合的距离</span><br><span class="line">	st[t]=true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>堆优化Prim</p>
<h5 id="克鲁斯卡尔算法（稀疏图"><a href="#克鲁斯卡尔算法（稀疏图" class="headerlink" title="克鲁斯卡尔算法（稀疏图)"></a>克鲁斯卡尔算法（稀疏图)</h5><p>需要变量：struct edge 因为只需要保存边的</p>
<p>算法思路： 先把所有边按权值排序，然后根据并查集找到集合没有的点且该边为所有边最小的边后加入集合，统计集合中点的数量，如果边的数量小于n-1说明没有联通，否则就输出最小生成树的权值</p>
<h5 id="染色法"><a href="#染色法" class="headerlink" title="染色法"></a>染色法</h5><p>判断是否是二分图的算法，通过dfs染色</p>
<p>注意无向图add的时候</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">bool dfs(int u, int color) &#123;</span><br><span class="line">    st[u] = color;</span><br><span class="line"></span><br><span class="line">    for(int i = h[u]; i != -1; i = ne[i])&#123;</span><br><span class="line">        int j = e[i];</span><br><span class="line">        if(!st[j]) &#123;</span><br><span class="line">            if(!dfs(j, 3 - color)) return false;</span><br><span class="line">        &#125;else if(st[j] == color) return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主函数注意每个点如果没染色都染色</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">bool flag = true;</span><br><span class="line">   for(int i = 1; i &lt;= n; i ++)&#123;</span><br><span class="line">       if(!st[i])&#123;</span><br><span class="line">           if(!dfs(i, 1))&#123;</span><br><span class="line">               flag = false;</span><br><span class="line">               break;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<h5 id="匈牙利算法"><a href="#匈牙利算法" class="headerlink" title="匈牙利算法"></a>匈牙利算法</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 510, M = 100010;</span><br><span class="line"></span><br><span class="line">int n1, n2, m;</span><br><span class="line">int h[N], e[M], ne[M], idx;</span><br><span class="line">int match[N];  // match[i]：女生i的对象</span><br><span class="line">bool query[N];  // bool st[N];  // 男生是否询问过女生</span><br><span class="line"></span><br><span class="line">void add(int a, int b) &#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int find(int x) &#123;</span><br><span class="line">    for (int i = h[x]; i != -1; i = ne[i]) &#123;  // 遍历男生x的所有可联系女生</span><br><span class="line">        int j = e[i];  // 女生的编号j</span><br><span class="line">        if (!query[j]) &#123;  // 如果没询问过</span><br><span class="line">            query[j] = true;  // 标记为询问，然后去问她</span><br><span class="line">            if (!match[j] || find(match[j]))&#123;  // 如果女生j没有对象，或者女生j的对象match[j]可以再找一个。  // highlight：query的作用就在这里，递归产生的find栈不会再去询问match[j]自己的对象j</span><br><span class="line">                match[j] = x;  // 那女生j把男生x作为对象</span><br><span class="line">                return true;  // 男生x成功找到对象（在未询问女生中）</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return false;  // 男生x没找着对象（在未询问女生中）</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    memset(h, -1, sizeof h);</span><br><span class="line"></span><br><span class="line">    scanf(&quot;%d%d%d&quot;, &amp;n1, &amp;n2, &amp;m);</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; m; i ++ ) &#123;</span><br><span class="line">        int a, b;</span><br><span class="line">        scanf(&quot;%d%d&quot;, &amp;a, &amp;b);</span><br><span class="line">        add(a, b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int res = 0;</span><br><span class="line">    for (int i = 1; i &lt;= n1; i ++ ) &#123;</span><br><span class="line">        memset(query, false, sizeof query);  // 重复使用query，每个男生最初都没有询问过女生</span><br><span class="line">        if (find(i)) res ++ ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printf(&quot;%d\n&quot;, res);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="数学知识"><a href="#数学知识" class="headerlink" title="数学知识"></a>数学知识</h4><p>筛质数 埃式筛法 线性筛法</p>
<p>从小到大枚举每个数</p>
<p>如果当前数没划掉，必定是质数，记录该质数，枚举当前质数的倍数，必定是合数，划掉合数。</p>
<p><img src="C:\Users\乌拉拉巴卡巴卡\AppData\Roaming\Typora\typora-user-images\image-20230106164833221.png" alt="image-20230106164833221"></p>
<p><img src="C:\Users\乌拉拉巴卡巴卡\AppData\Roaming\Typora\typora-user-images\image-20230106181915190.png" alt="image-20230106181915190"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">6.2:埃氏筛(稍加优化版的筛法).</span><br><span class="line">(1).质数定理:1~n中有n/lnn个质数.</span><br><span class="line">(2).原理:在朴素筛法的过程中只用质数项去筛.</span><br><span class="line">(3).时间复杂度:粗略估计:O(n).实际:O(nlog(logn)).</span><br><span class="line">(4).1~n中,只计算质数项的话,”1/2+1/3+1/4+1/5+…+1/n”的大小约为log(logn).</span><br><span class="line">6.3:线性筛</span><br><span class="line">(1).若n在10的6次方的话,线性筛和埃氏筛的时间效率差不多,若n在10的7次方的话,线性筛会比埃氏筛快了大概一倍.</span><br><span class="line">(2).思考:一:线性筛法为什么是线性的?</span><br><span class="line">二:线性筛法的原理是什么?</span><br><span class="line">(3).核心:1~n内的合数p只会被其最小质因子筛掉.</span><br><span class="line">(4).原理:1~n之内的任何一个合数一定会被筛掉,而且筛的时候只用最小质因子来筛,</span><br><span class="line">然后每一个数都只有一个最小质因子,因此每个数都只会被筛一次,因此线性筛法是线性的.</span><br><span class="line">(5).枚举到i的最小质因子的时候就会停下来,即”if(i%primes[j]==0) break;”.</span><br><span class="line">(6).因为从小到大枚举的所有质数,所以当”i%primes[j]!=0”时,primes[j]一定小于i的最小质因子,</span><br><span class="line">primes[j]一定是primes[j]i的最小质因子.</span><br><span class="line">(7).因为是从小到大枚举的所有质数,所以当”i%primes[j]==0”时,primes[j]一定是i的最小质因子,</span><br><span class="line">而primes[j]又是primes[j]的最小质因子,因此primes[j]是iprimes[j]的最小质因子.</span><br><span class="line">(8).关于for循环的解释:</span><br><span class="line">注:首先要把握住一个重点:我们枚举的时候是从小到大枚举的所有质数</span><br><span class="line">1.当i%primes[j]==0时,因为是从小到大枚举的所有质数,所以primes[j]就是i的最小质因子,而primes[j]又是其本身</span><br><span class="line">primes[j]的最小质因子,因此当i%primes[j]==0时,primes[j]是primes[j]i的最小质因子.</span><br><span class="line">2.当i%primes[j]!=0时,因为是从小到大枚举的所有质数,且此时并没有出现过有质数满足i%primes[j]==0,</span><br><span class="line">因此此时的primes[j]一定小于i的最小质因子,而primes[j]又是其本身primes[j]的最小质因子,</span><br><span class="line">所以当i%primes[j]!=0时,primes[j]也是primes[j]*i的最小质因子.</span><br><span class="line">3.综合1,2得知,在内层for循环里面无论何时,primes[j]都是primes[j]i的最小质因子,因此”st[primes[j]*i]=true”</span><br><span class="line">语句就是用primes[j]i这个数的最小质因子来筛掉这个数.</span><br></pre></td></tr></table></figure>


<p>分解质因数 唯一分解定理 试除法</p>
<p><img src="C:\Users\乌拉拉巴卡巴卡\AppData\Roaming\Typora\typora-user-images\image-20230107103929896.png" alt="image-20230107103929896"></p>
<p> <img src="C:\Users\乌拉拉巴卡巴卡\AppData\Roaming\Typora\typora-user-images\image-20230111105948906.png" alt="image-20230111105948906"></p>
<p><ifram src="//player.bilibili.com/player.html?aid=763614192&bvid=BV19r4y127fu&cid=424201509&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" > </iframe></p>
<h4 id="C-STL"><a href="#C-STL" class="headerlink" title="C++ STL"></a>C++ STL</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_39838607/article/details/119653496">(14条消息) c++ map通过值找键与通过键找值得方法(全）_c++中map怎么用值查键_落春只在无意间的博客-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/blog/content/25/">求解斐波那契数列的若干方法 - AcWing</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/yas12345678/article/details/52601454">(61条消息) C++中set用法详解_c++ set_Donny-You的博客-CSDN博客</a></p>
<h4 id="石子合并"><a href="#石子合并" class="headerlink" title="石子合并"></a>石子合并</h4><p>每次合并两个最小的</p>
<p>A B C</p>
<p>A《B《C</p>
<p>A+B+A+B+C《B+C+B+C+A</p>
<p>同时我要知道合并之后此时邻居下一次最小的是谁</p>
<p>问题变成怎么快速找到一个数组里面a[i]+a[i+1]最小的</p>
<p>但注意到先合并和较小的两个的结果一般较优，考虑是否能按先合并小的来求最小值，这种方法是错误的</p>
<p>当其中一个数 与左边合并 和与右边合并消耗相同时，选法不同，结果会不同 ，贪心随机选左边或右边所以不一定正确。</p>
<p>关键点：最后一次合并一定是左边连续的一部分和右边连续的一部分进行合并</p>
<p><strong>递归搜索+保存计划结果&#x3D;记忆化搜索</strong></p>
<p>把递归的计算结果保存下来，那么下次递归到同样的入参时就直接返回先前保存的结果<img src="C:\Users\乌拉拉巴卡巴卡\AppData\Roaming\Typora\typora-user-images\image-20231129210717353.png" alt="image-20231129210717353" style="zoom:67%;" /></p>
<p>石子合并</p>
<p>递归写法（暴力写法）</p>
<p>思路：递归，hash判断是否这个stock被合了无了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> n=<span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> N;</span><br><span class="line"><span class="type">int</span> stocks[n];</span><br><span class="line"><span class="type">int</span> hash[n];</span><br><span class="line"><span class="type">int</span> record[n][<span class="number">2</span>]; </span><br><span class="line"><span class="type">int</span> min=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span>* stocks,<span class="type">int</span> cost,<span class="type">int</span> cnt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(cnt==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//   for(int i=N-1;i&gt;0;i--)</span></span><br><span class="line">        <span class="comment">//   &#123;</span></span><br><span class="line">        <span class="comment">//       printf(&quot;%d %d\n&quot;,record[i][0],record[i][1]);</span></span><br><span class="line">        <span class="comment">//   &#125;</span></span><br><span class="line">        <span class="comment">//   printf(&quot;cost%d &quot;,cost);</span></span><br><span class="line">      <span class="keyword">if</span>(min&gt;cost) &#123;</span><br><span class="line">          min = cost;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//   printf(&quot;\n&quot;);</span></span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N<span class="number">-1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(hash[i]) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> second=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i<span class="number">+1</span>;j&lt;N;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(hash[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    second = j;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">        </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(second==N) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">int</span> tmp = stocks[second];</span><br><span class="line">            hash[i]=<span class="number">0</span>,stocks[second]=stocks[second]+stocks[i];</span><br><span class="line">            record[cnt][<span class="number">0</span>]=i;</span><br><span class="line">            record[cnt][<span class="number">1</span>]=i<span class="number">+1</span>;</span><br><span class="line">            <span class="comment">// printf(&quot;co%d &quot;,cost);</span></span><br><span class="line">             <span class="built_in">dfs</span>(stocks,cost+stocks[second],cnt<span class="number">-1</span>);</span><br><span class="line">            hash[i]=<span class="number">1</span>,stocks[second]=tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;N);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;stocks[i]);</span><br><span class="line">        hash[i]=<span class="number">1</span>;</span><br><span class="line">        record[i][<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">        record[i][<span class="number">1</span>]=<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(stocks,<span class="number">0</span>,N<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,min);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>转化为记忆化搜索</p>
<img src="D:\typora笔记\基础算法.assets\image-20231202205741869.png" alt="image-20231202205741869" style="zoom:50%;" />

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">310</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[N],dp[N][N];</span><br><span class="line"><span class="type">int</span> s[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(dp[l][r]!=<span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> dp[l][r];</span><br><span class="line">    <span class="keyword">if</span>(l==r) &#123;</span><br><span class="line">        dp[l][r]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> min=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=l;i&lt;r;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">        min=min&gt;<span class="built_in">dfs</span>(l,i)+<span class="built_in">dfs</span>(i<span class="number">+1</span>,r)?<span class="built_in">dfs</span>(l,i)+<span class="built_in">dfs</span>(i<span class="number">+1</span>,r):min;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">    dp[l][r]=min+s[r]-s[l<span class="number">-1</span>];</span><br><span class="line">    <span class="comment">// printf(&quot;%d = dp[%d][%d] &quot;,dp[l][r],l,r);</span></span><br><span class="line">     <span class="keyword">return</span> dp[l][r];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">        s[i]=s[i<span class="number">-1</span>]+a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">0x3f3f3f3f</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="built_in">dfs</span>(<span class="number">1</span>,n));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="D:\typora笔记\基础算法.assets\image-20231202215110757.png" alt="image-20231202215110757" style="zoom:50%;" />

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2025/02/04/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/" rel="next" title="二分查找">
                <i class="fa fa-chevron-left"></i> 二分查找
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2025/02/05/%E3%80%90Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E3%80%91const%E5%92%8Citoa/" rel="prev" title="">
                 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="" />
          <p class="site-author-name" itemprop="name"></p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">43</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#title-Acwing%E7%9A%84%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95"><span class="nav-number">1.</span> <span class="nav-text">title:Acwing的基础算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="nav-number">1.0.1.</span> <span class="nav-text">快速排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%AB%98%E7%B2%BE%E5%BA%A6%E4%B9%98%E6%B3%95"><span class="nav-number">1.0.2.</span> <span class="nav-text">高精度乘法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86"><span class="nav-number">1.0.3.</span> <span class="nav-text">前缀和与差分</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%AE%97%E6%B3%95"><span class="nav-number">1.0.4.</span> <span class="nav-text">二进制算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%95%E9%93%BE%E8%A1%A8%EF%BC%9A"><span class="nav-number">1.0.5.</span> <span class="nav-text">单链表：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%8C%E9%93%BE%E8%A1%A8%EF%BC%9A"><span class="nav-number">1.0.6.</span> <span class="nav-text">双链表：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%88%EF%BC%9A"><span class="nav-number">1.0.7.</span> <span class="nav-text">栈：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%99%AE%E9%80%9A%E9%98%9F%E5%88%97%EF%BC%9A"><span class="nav-number">1.0.8.</span> <span class="nav-text">普通队列：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97%EF%BC%9A"><span class="nav-number">1.0.9.</span> <span class="nav-text">循环队列：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%95%E8%B0%83%E6%A0%88%EF%BC%9A"><span class="nav-number">1.0.10.</span> <span class="nav-text">单调栈：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%EF%BC%9A"><span class="nav-number">1.0.11.</span> <span class="nav-text">单调队列：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#KMP%E7%AE%97%E6%B3%95"><span class="nav-number">1.0.12.</span> <span class="nav-text">KMP算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Tire%E6%A0%91"><span class="nav-number">1.0.13.</span> <span class="nav-text">Tire树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86%EF%BC%9A"><span class="nav-number">1.0.14.</span> <span class="nav-text">并查集：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A0%86%EF%BC%9A"><span class="nav-number">1.0.15.</span> <span class="nav-text">堆：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="nav-number">1.0.16.</span> <span class="nav-text">哈希表</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%80%E8%88%AC%E5%93%88%E5%B8%8C%EF%BC%9A"><span class="nav-number">1.0.16.1.</span> <span class="nav-text">一般哈希：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C"><span class="nav-number">1.0.16.2.</span> <span class="nav-text">字符串哈希</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%BE%E8%AE%BA"><span class="nav-number">1.0.17.</span> <span class="nav-text">图论</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE"><span class="nav-number">1.0.17.1.</span> <span class="nav-text">思维导图</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Dijkstra%E7%AE%97%E6%B3%95"><span class="nav-number">1.0.17.2.</span> <span class="nav-text">Dijkstra算法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#bellman-ford%E7%AE%97%E6%B3%95"><span class="nav-number">1.0.17.3.</span> <span class="nav-text">bellman_ford算法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#spfa%EF%BC%88%E7%A8%80%E7%96%8F%E5%9B%BE%EF%BC%89"><span class="nav-number">1.0.17.4.</span> <span class="nav-text">spfa（稀疏图）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Floyd"><span class="nav-number">1.0.17.5.</span> <span class="nav-text">Floyd</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Prim"><span class="nav-number">1.0.17.6.</span> <span class="nav-text">Prim</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%8B%E9%B2%81%E6%96%AF%E5%8D%A1%E5%B0%94%E7%AE%97%E6%B3%95%EF%BC%88%E7%A8%80%E7%96%8F%E5%9B%BE"><span class="nav-number">1.0.17.7.</span> <span class="nav-text">克鲁斯卡尔算法（稀疏图)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9F%93%E8%89%B2%E6%B3%95"><span class="nav-number">1.0.17.8.</span> <span class="nav-text">染色法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95"><span class="nav-number">1.0.17.9.</span> <span class="nav-text">匈牙利算法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86"><span class="nav-number">1.0.18.</span> <span class="nav-text">数学知识</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#C-STL"><span class="nav-number">1.0.19.</span> <span class="nav-text">C++ STL</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9F%B3%E5%AD%90%E5%90%88%E5%B9%B6"><span class="nav-number">1.0.20.</span> <span class="nav-text">石子合并</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" target="_blank" rel="noopener" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" target="_blank" rel="noopener" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Gemini
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.2"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  





  

  

  

  

  

  

</body>
</html>
